"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[792],{2325:function(t,a,e){var n=e(1876).Buffer;Object.defineProperty(a,"__esModule",{value:!0});var i=e(2223),r=e(496),o=e(7060),s=(e(3544),e(2474)),c=e(7172),l=e(5131),u=e(4285),d=e(7083),w=e(1094);function f(t){return t&&"object"===typeof t&&"default"in t?t:{default:t}}function p(t){if(t&&t.__esModule)return t;var a=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var n=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(a,e,n.get?n:{enumerable:!0,get:function(){return t[e]}})}})),a.default=t,Object.freeze(a)}var g=p(i),m=f(o),h=f(s),b=p(c),y=f(d),G=f(w);r.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),r.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");const S=r.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),_=r.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function v(t){let a;if(r.Scalar.eq(t,_))a=await r.buildBn128();else{if(!r.Scalar.eq(t,S))throw new Error(`Curve not supported: ${r.Scalar.toString(t)}`);a=await r.buildBls12381()}return a}async function F(t){let a;const e=t.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(e)>=0)a=await r.buildBn128();else{if(!(["BLS12381"].indexOf(e)>=0))throw new Error(`Curve not supported: ${t}`);a=await r.buildBls12381()}return a}function E(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)}function B(t,a){const e=new DataView(t.buffer,t.byteOffset,t.byteLength);let n="";for(let i=0;i<4;i++){i>0&&(n+="\n"),n+="\t\t";for(let t=0;t<4;t++)t>0&&(n+=" "),n+=e.getUint32(16*i+4*t).toString(16).padStart(8,"0")}return a&&(n=a+"\n"+n),n}function x(t,a){if(t.byteLength!=a.byteLength)return!1;for(var e=new Int8Array(t),n=new Int8Array(a),i=0;i!=t.byteLength;i++)if(e[i]!=n[i])return!1;return!0}function A(t){const a=t.getPartialHash(),e=m.default(64);return e.setPartialHash(a),e}async function U(t,a,e,n,i){if(t.G1.isZero(a))return!1;if(t.G1.isZero(e))return!1;if(t.G2.isZero(n))return!1;if(t.G2.isZero(i))return!1;return await t.pairingEq(a,i,t.G1.neg(e),n)}async function L(t){for(;!t;)t=await window.prompt("Enter a random text. (Entropy): ","");const a=m.default(64);a.update(h.default.randomBytes(64));const e=new TextEncoder;a.update(e.encode(t));const i=n.from(a.digest()),o=[];for(let n=0;n<8;n++)o[n]=i.readUInt32BE(4*n);return new r.ChaCha(o)}function z(t,a){let e,n;a<32?(e=1<<a>>>0,n=1):(e=4294967296,n=1<<a-32>>>0);let i=t;for(let r=0;r<n;r++)for(let t=0;t<e;t++)i=h.default.createHash("sha256").update(i).digest();const o=new DataView(i.buffer,i.byteOffset,i.byteLength),s=[];for(let r=0;r<8;r++)s[r]=o.getUint32(4*r,!1);return new r.ChaCha(s)}function R(t){return t instanceof Uint8Array?t:("0x"==t.slice(0,2)&&(t=t.slice(2)),new Uint8Array(t.match(/[\da-f]{2}/gi).map((function(t){return parseInt(t,16)}))))}function k(t){return Array.prototype.map.call(t,(function(t){return("0"+(255&t).toString(16)).slice(-2)})).join("")}async function T(t,a){await g.startWriteSection(t,1),await t.writeULE32(1),await g.endWriteSection(t);const e=await v(a.q);await g.startWriteSection(t,2);const n=e.q,i=8*(Math.floor((r.Scalar.bitLength(n)-1)/64)+1),o=e.r,s=8*(Math.floor((r.Scalar.bitLength(o)-1)/64)+1);await t.writeULE32(i),await g.writeBigInt(t,n,i),await t.writeULE32(s),await g.writeBigInt(t,o,s),await t.writeULE32(a.nVars),await t.writeULE32(a.nPublic),await t.writeULE32(a.domainSize),await C(t,e,a.vk_alpha_1),await C(t,e,a.vk_beta_1),await I(t,e,a.vk_beta_2),await I(t,e,a.vk_gamma_2),await C(t,e,a.vk_delta_1),await I(t,e,a.vk_delta_2),await g.endWriteSection(t)}async function C(t,a,e){const n=new Uint8Array(2*a.G1.F.n8);a.G1.toRprLEM(n,0,e),await t.write(n)}async function I(t,a,e){const n=new Uint8Array(2*a.G2.F.n8);a.G2.toRprLEM(n,0,e),await t.write(n)}async function $(t,a,e){const n=await t.read(2*a.G1.F.n8),i=a.G1.fromRprLEM(n,0);return e?a.G1.toObject(i):i}async function O(t,a,e){const n=await t.read(2*a.G2.F.n8),i=a.G2.fromRprLEM(n,0);return e?a.G2.toObject(i):i}async function M(t,a,e){await g.startReadUniqueSection(t,a,1);const n=await t.readULE32();if(await g.endReadSection(t),1==n)return await async function(t,a,e){const n={protocol:"groth16"};await g.startReadUniqueSection(t,a,2);const i=await t.readULE32();n.n8q=i,n.q=await g.readBigInt(t,i);const r=await t.readULE32();return n.n8r=r,n.r=await g.readBigInt(t,r),n.curve=await v(n.q),n.nVars=await t.readULE32(),n.nPublic=await t.readULE32(),n.domainSize=await t.readULE32(),n.power=E(n.domainSize),n.vk_alpha_1=await $(t,n.curve,e),n.vk_beta_1=await $(t,n.curve,e),n.vk_beta_2=await O(t,n.curve,e),n.vk_gamma_2=await O(t,n.curve,e),n.vk_delta_1=await $(t,n.curve,e),n.vk_delta_2=await O(t,n.curve,e),await g.endReadSection(t),n}(t,a,e);if(2==n)return await async function(t,a,e,n){const i={protocol:"plonk"};await g.startReadUniqueSection(t,a,2);const r=await t.readULE32();i.n8q=r,i.q=await g.readBigInt(t,r);const o=await t.readULE32();return i.n8r=o,i.r=await g.readBigInt(t,o),i.curve=await v(i.q),i.nVars=await t.readULE32(),i.nPublic=await t.readULE32(),i.domainSize=await t.readULE32(),i.power=E(i.domainSize),i.nAdditions=await t.readULE32(),i.nConstrains=await t.readULE32(),i.k1=await t.read(o),i.k2=await t.read(o),i.Qm=await $(t,i.curve,n),i.Ql=await $(t,i.curve,n),i.Qr=await $(t,i.curve,n),i.Qo=await $(t,i.curve,n),i.Qc=await $(t,i.curve,n),i.S1=await $(t,i.curve,n),i.S2=await $(t,i.curve,n),i.S3=await $(t,i.curve,n),i.X_2=await O(t,i.curve,n),await g.endReadSection(t),i}(t,a);throw new Error("Protocol not supported: ")}async function P(t,a,e){const n={delta:{}};n.deltaAfter=await $(t,a,e),n.delta.g1_s=await $(t,a,e),n.delta.g1_sx=await $(t,a,e),n.delta.g2_spx=await O(t,a,e),n.transcript=await t.read(64),n.type=await t.readULE32();const i=await t.readULE32(),r=t.pos;let o=0;for(;t.pos-r<i;){const a=await t.read(1);if(a[0]<=o)throw new Error("Parameters in the contribution must be sorted");if(o=a[0],1==a[0]){const a=await t.read(1),e=await t.read(a[0]);n.name=(new TextDecoder).decode(e)}else if(2==a[0]){const a=await t.read(1);n.numIterationsExp=a[0]}else{if(3!=a[0])throw new Error("Parameter not recognized");{const a=await t.read(1);n.beaconHash=await t.read(a[0])}}}if(t.pos!=r+i)throw new Error("Parametes do not match");return n}async function q(t,a,e){await g.startReadUniqueSection(t,e,10);const n={contributions:[]};n.csHash=await t.read(64);const i=await t.readULE32();for(let r=0;r<i;r++){const e=await P(t,a);n.contributions.push(e)}return await g.endReadSection(t),n}async function W(t,a,e){await C(t,a,e.deltaAfter),await C(t,a,e.delta.g1_s),await C(t,a,e.delta.g1_sx),await I(t,a,e.delta.g2_spx),await t.write(e.transcript),await t.writeULE32(e.type||0);const n=[];if(e.name){n.push(1);const t=new TextEncoder("utf-8").encode(e.name.substring(0,64));n.push(t.byteLength);for(let a=0;a<t.byteLength;a++)n.push(t[a])}if(1==e.type){n.push(2),n.push(e.numIterationsExp),n.push(3),n.push(e.beaconHash.byteLength);for(let t=0;t<e.beaconHash.byteLength;t++)n.push(e.beaconHash[t])}if(n.length>0){const a=new Uint8Array(n);await t.writeULE32(a.byteLength),await t.write(a)}else await t.writeULE32(0)}async function j(t,a,e){await g.startWriteSection(t,10),await t.write(e.csHash),await t.writeULE32(e.contributions.length);for(let n=0;n<e.contributions.length;n++)await W(t,a,e.contributions[n]);await g.endWriteSection(t)}function H(t,a,e){const n=new Uint8Array(2*a.G1.F.n8);a.G1.toRprUncompressed(n,0,e),t.update(n)}function V(t,a,e){H(t,a,e.deltaAfter),H(t,a,e.delta.g1_s),H(t,a,e.delta.g1_sx),function(t,a,e){const n=new Uint8Array(2*a.G2.F.n8);a.G2.toRprUncompressed(n,0,e),t.update(n)}(t,a,e.delta.g2_spx),t.update(e.transcript)}async function N(t,a){await g.startReadUniqueSection(t,a,1);const e=await t.readULE32(),n=await g.readBigInt(t,e),i=await t.readULE32();return await g.endReadSection(t),{n8:e,q:n,nWitness:i}}const{stringifyBigInts:K}=r.utils;async function D(t,a,e){const{fd:n,sections:i}=await g.readBinFile(a,"wtns",2,1<<25,1<<23),o=await N(n,i),{fd:s,sections:c}=await g.readBinFile(t,"zkey",2,1<<25,1<<23),l=await M(s,c);if("groth16"!=l.protocol)throw new Error("zkey file is not groth16");if(!r.Scalar.eq(l.r,o.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=l.nVars)throw new Error(`Invalid witness length. Circuit: ${l.nVars}, witness: ${o.nWitness}`);const u=l.curve,d=u.Fr,w=u.G1,f=u.G2,p=E(l.domainSize);e&&e.debug("Reading Wtns");const m=await g.readSection(n,i,2);e&&e.debug("Reading Coeffs");const h=await g.readSection(s,c,4);e&&e.debug("Building ABC");const[b,y,G]=await async function(t,a,e,n,i){const o=t.Fr.n8,s=12+a.n8r,c=(n.byteLength-4)/s,l=new r.BigBuffer(a.domainSize*o),u=new r.BigBuffer(a.domainSize*o),d=new r.BigBuffer(a.domainSize*o),w=[l,u];for(let r=0;r<c;r++){i&&r%1e6==0&&i.debug(`QAP AB: ${r}/${c}`);const a=n.slice(4+r*s,4+r*s+s),l=new DataView(a.buffer),u=l.getUint32(0,!0),d=l.getUint32(4,!0),f=l.getUint32(8,!0),p=a.slice(12,12+o);w[u].set(t.Fr.add(w[u].slice(d*o,d*o+o),t.Fr.mul(p,e.slice(f*o,f*o+o))),d*o)}for(let r=0;r<a.domainSize;r++)i&&r%1e6==0&&i.debug(`QAP C: ${r}/${a.domainSize}`),d.set(t.Fr.mul(l.slice(r*o,r*o+o),u.slice(r*o,r*o+o)),r*o);return[l,u,d]}(u,l,m,h,e),S=p==d.s?u.Fr.shift:u.Fr.w[p+1],_=await d.ifft(b,"","",e,"IFFT_A"),v=await d.batchApplyKey(_,d.e(1),S),F=await d.fft(v,"","",e,"FFT_A"),B=await d.ifft(y,"","",e,"IFFT_B"),x=await d.batchApplyKey(B,d.e(1),S),A=await d.fft(x,"","",e,"FFT_B"),U=await d.ifft(G,"","",e,"IFFT_C"),L=await d.batchApplyKey(U,d.e(1),S),z=await d.fft(L,"","",e,"FFT_C");e&&e.debug("Join ABC");const R=await async function(t,a,e,n,i,o){const s=1<<22,c=t.Fr.n8,l=Math.floor(e.byteLength/t.Fr.n8),u=[];for(let r=0;r<l;r+=s){o&&o.debug(`JoinABC: ${r}/${l}`);const a=Math.min(l-r,s),d=[],w=e.slice(r*c,(r+a)*c),f=n.slice(r*c,(r+a)*c),p=i.slice(r*c,(r+a)*c);d.push({cmd:"ALLOCSET",var:0,buff:w}),d.push({cmd:"ALLOCSET",var:1,buff:f}),d.push({cmd:"ALLOCSET",var:2,buff:p}),d.push({cmd:"ALLOC",var:3,len:a*c}),d.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:a},{var:3}]}),d.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:a},{var:3}]}),d.push({cmd:"GET",out:0,var:3,len:a*c}),u.push(t.tm.queueAction(d))}const d=await Promise.all(u);let w;w=e instanceof r.BigBuffer?new r.BigBuffer(e.byteLength):new Uint8Array(e.byteLength);let f=0;for(let r=0;r<d.length;r++)w.set(d[r][0],f),f+=d[r][0].byteLength;return w}(u,0,F,A,z,e);let k={};e&&e.debug("Reading A Points");const T=await g.readSection(s,c,5);k.pi_a=await u.G1.multiExpAffine(T,m,e,"multiexp A"),e&&e.debug("Reading B1 Points");const C=await g.readSection(s,c,6);let I=await u.G1.multiExpAffine(C,m,e,"multiexp B1");e&&e.debug("Reading B2 Points");const $=await g.readSection(s,c,7);k.pi_b=await u.G2.multiExpAffine($,m,e,"multiexp B2"),e&&e.debug("Reading C Points");const O=await g.readSection(s,c,8);k.pi_c=await u.G1.multiExpAffine(O,m.slice((l.nPublic+1)*u.Fr.n8),e,"multiexp C"),e&&e.debug("Reading H Points");const P=await g.readSection(s,c,9),q=await u.G1.multiExpAffine(P,R,e,"multiexp H"),W=u.Fr.random(),j=u.Fr.random();k.pi_a=w.add(k.pi_a,l.vk_alpha_1),k.pi_a=w.add(k.pi_a,w.timesFr(l.vk_delta_1,W)),k.pi_b=f.add(k.pi_b,l.vk_beta_2),k.pi_b=f.add(k.pi_b,f.timesFr(l.vk_delta_2,j)),I=w.add(I,l.vk_beta_1),I=w.add(I,w.timesFr(l.vk_delta_1,j)),k.pi_c=w.add(k.pi_c,q),k.pi_c=w.add(k.pi_c,w.timesFr(k.pi_a,j)),k.pi_c=w.add(k.pi_c,w.timesFr(I,W)),k.pi_c=w.add(k.pi_c,w.timesFr(l.vk_delta_1,d.neg(d.mul(W,j))));let H=[];for(let g=1;g<=l.nPublic;g++){const t=m.slice(g*d.n8,g*d.n8+d.n8);H.push(r.Scalar.fromRprLE(t))}return k.pi_a=w.toObject(w.toAffine(k.pi_a)),k.pi_b=f.toObject(f.toAffine(k.pi_b)),k.pi_c=w.toObject(w.toAffine(k.pi_c)),k.protocol="groth16",k.curve=u.name,await s.close(),await n.close(),k=K(k),H=K(H),{proof:k,publicSignals:H}}const{unstringifyBigInts:Q}=r.utils;async function Z(t,a,e,n){const i=Q(t),o=await b.readExisting(a),s=await o.read(o.totalSize);await o.close();const c=await l.WitnessCalculatorBuilder(s);if(1==c.circom_version()){const t=await c.calculateBinWitness(i),a=await g.createBinFile(e,"wtns",2,2);await async function(t,a,e){await g.startWriteSection(t,1);const n=8*(Math.floor((r.Scalar.bitLength(e)-1)/64)+1);if(await t.writeULE32(n),await g.writeBigInt(t,e,n),a.byteLength%n!=0)throw new Error("Invalid witness length");await t.writeULE32(a.byteLength/n),await g.endWriteSection(t),await g.startWriteSection(t,2),await t.write(a),await g.endWriteSection(t)}(a,t,c.prime),await a.close()}else{const t=await b.createOverride(e),a=await c.calculateWTNSBin(i);await t.write(a),await t.close()}}const{unstringifyBigInts:J}=r.utils;const{unstringifyBigInts:X}=r.utils;const{unstringifyBigInts:Y}=r.utils;function tt(t){let a=t.toString(16);for(;a.length<64;)a="0"+a;return a=`"0x${a}"`,a}var at=Object.freeze({__proto__:null,fullProve:async function(t,a,e,n){const i=J(t),r={type:"mem"};return await Z(i,a,r),await D(e,r,n)},prove:D,verify:async function(t,a,e,n){const i=X(t),o=X(e),s=X(a),c=await F(i.curve),l=c.G1.fromObject(i.IC[0]),u=new Uint8Array(2*c.G1.F.n8*s.length),d=new Uint8Array(c.Fr.n8*s.length);for(let G=0;G<s.length;G++){const t=c.G1.fromObject(i.IC[G+1]);u.set(t,G*c.G1.F.n8*2),r.Scalar.toRprLE(d,c.Fr.n8*G,s[G],c.Fr.n8)}let w=await c.G1.multiExpAffine(u,d);w=c.G1.add(w,l);const f=c.G1.fromObject(o.pi_a),p=c.G2.fromObject(o.pi_b),g=c.G1.fromObject(o.pi_c),m=c.G2.fromObject(i.vk_gamma_2),h=c.G2.fromObject(i.vk_delta_2),b=c.G1.fromObject(i.vk_alpha_1),y=c.G2.fromObject(i.vk_beta_2);return await c.pairingEq(c.G1.neg(f),p,w,m,g,h,b,y)?(n&&n.info("OK!"),!0):(n&&n.error("Invalid proof"),!1)},exportSolidityCallData:async function(t,a){const e=Y(t),n=Y(a);let i,r="";for(let o=0;o<n.length;o++)""!=r&&(r+=","),r+=tt(n[o]);return i=`[${tt(e.pi_a[0])}, ${tt(e.pi_a[1])}],[[${tt(e.pi_b[0][1])}, ${tt(e.pi_b[0][0])}],[${tt(e.pi_b[1][1])}, ${tt(e.pi_b[1][0])}]],[${tt(e.pi_c[0])}, ${tt(e.pi_c[1])}],[${r}]`,i}});function et(t,a){const e=new DataView(a.buffer,a.byteOffset,a.byteLength),n=[];for(let r=0;r<8;r++)n[r]=e.getUint32(4*r);const i=new r.ChaCha(n);return t.G2.fromRng(i)}function nt(t,a,e,n,i){const r=m.default(64),o=new Uint8Array([a]);r.update(o),r.update(e);const s=t.G1.toUncompressed(n);r.update(s);const c=t.G1.toUncompressed(i);r.update(c);return et(t,r.digest())}function it(t,a,e,n,i){return t.g1_s=a.G1.toAffine(a.G1.fromRng(i)),t.g1_sx=a.G1.toAffine(a.G1.timesFr(t.g1_s,t.prvKey)),t.g2_sp=a.G2.toAffine(nt(a,e,n,t.g1_s,t.g1_sx)),t.g2_spx=a.G2.toAffine(a.G2.timesFr(t.g2_sp,t.prvKey)),t}function rt(t,a,e){const n={tau:{},alpha:{},beta:{}};return n.tau.prvKey=t.Fr.fromRng(e),n.alpha.prvKey=t.Fr.fromRng(e),n.beta.prvKey=t.Fr.fromRng(e),it(n.tau,t,0,a,e),it(n.alpha,t,1,a,e),it(n.beta,t,2,a,e),n}async function ot(t,a,e,n){n||(n=e),await t.writeULE32(1);const i=t.pos;await t.writeULE64(0),await t.writeULE32(8*a.F1.n64);const o=new Uint8Array(a.F1.n8);r.Scalar.toRprLE(o,0,a.q,a.F1.n8),await t.write(o),await t.writeULE32(e),await t.writeULE32(n);const s=t.pos-i-8,c=t.pos;await t.writeULE64(s,i),t.pos=c}async function st(t,a){if(!a[1])throw new Error(t.fileName+": File has no  header");if(a[1].length>1)throw new Error(t.fileName+": File has more than one header");t.pos=a[1][0].p;const e=await t.readULE32(),n=await t.read(e),i=r.Scalar.fromRprLE(n),o=await v(i);if(8*o.F1.n64!=e)throw new Error(t.fileName+": Invalid size");const s=await t.readULE32(),c=await t.readULE32();if(t.pos-a[1][0].p!=a[1][0].size)throw new Error("Invalid PTau header size");return{curve:o,power:s,ceremonyPower:c}}function ct(t,a,e,n){const i={tau:{},alpha:{},beta:{}};return i.tau.g1_s=r(),i.tau.g1_sx=r(),i.alpha.g1_s=r(),i.alpha.g1_sx=r(),i.beta.g1_s=r(),i.beta.g1_sx=r(),i.tau.g2_spx=o(),i.alpha.g2_spx=o(),i.beta.g2_spx=o(),i;function r(){let i;return i=n?e.G1.fromRprLEM(t,a):e.G1.fromRprUncompressed(t,a),a+=2*e.G1.F.n8,i}function o(){let i;return i=n?e.G2.fromRprLEM(t,a):e.G2.fromRprUncompressed(t,a),a+=2*e.G2.F.n8,i}}function lt(t,a,e,n,i){async function r(n){i?e.G1.toRprLEM(t,a,n):e.G1.toRprUncompressed(t,a,n),a+=2*e.F1.n8}async function o(n){i?e.G2.toRprLEM(t,a,n):e.G2.toRprUncompressed(t,a,n),a+=2*e.F2.n8}return r(n.tau.g1_s),r(n.tau.g1_sx),r(n.alpha.g1_s),r(n.alpha.g1_sx),r(n.beta.g1_s),r(n.beta.g1_sx),o(n.tau.g2_spx),o(n.alpha.g2_spx),o(n.beta.g2_spx),t}async function ut(t,a){const e={};e.tauG1=await c(),e.tauG2=await l(),e.alphaG1=await c(),e.betaG1=await c(),e.betaG2=await l(),e.key=await async function(t,a,e){return ct(await t.read(2*a.F1.n8*6+2*a.F2.n8*3),0,a,e)}(t,a,!0),e.partialHash=await t.read(216),e.nextChallenge=await t.read(64),e.type=await t.readULE32();const n=new Uint8Array(2*a.G1.F.n8*6+2*a.G2.F.n8*3);lt(n,0,a,e.key,!1);const i=m.default(64);i.setPartialHash(e.partialHash),i.update(n),e.responseHash=i.digest();const r=await t.readULE32(),o=t.pos;let s=0;for(;t.pos-o<r;){const t=await u(1);if(t[0]<=s)throw new Error("Parameters in the contribution must be sorted");if(s=t[0],1==t[0]){const t=await u(1),a=await u(t[0]);e.name=(new TextDecoder).decode(a)}else if(2==t[0]){const t=await u(1);e.numIterationsExp=t[0]}else{if(3!=t[0])throw new Error("Parameter not recognized");{const t=await u(1);e.beaconHash=await u(t[0])}}}if(t.pos!=o+r)throw new Error("Parametes do not match");return e;async function c(){const e=await t.read(2*a.G1.F.n8);return a.G1.fromRprLEM(e)}async function l(){const e=await t.read(2*a.G2.F.n8);return a.G2.fromRprLEM(e)}async function u(a){const e=await t.read(a);return new Uint8Array(e)}}async function dt(t,a,e){if(!e[7])throw new Error(t.fileName+": File has no  contributions");if(e[7][0].length>1)throw new Error(t.fileName+": File has more than one contributions section");t.pos=e[7][0].p;const n=await t.readULE32(),i=[];for(let r=0;r<n;r++){const e=await ut(t,a);e.id=r+1,i.push(e)}if(t.pos-e[7][0].p!=e[7][0].size)throw new Error("Invalid contribution section size");return i}async function wt(t,a,e){const n=new Uint8Array(2*a.F1.n8),i=new Uint8Array(2*a.F2.n8);await o(e.tauG1),await s(e.tauG2),await o(e.alphaG1),await o(e.betaG1),await s(e.betaG2),await async function(t,a,e,n){const i=new Uint8Array(2*a.F1.n8*6+2*a.F2.n8*3);lt(i,0,a,e,n),await t.write(i)}(t,a,e.key,!0),await t.write(e.partialHash),await t.write(e.nextChallenge),await t.writeULE32(e.type||0);const r=[];if(e.name){r.push(1);const t=new TextEncoder("utf-8").encode(e.name.substring(0,64));r.push(t.byteLength);for(let a=0;a<t.byteLength;a++)r.push(t[a])}if(1==e.type){r.push(2),r.push(e.numIterationsExp),r.push(3),r.push(e.beaconHash.byteLength);for(let t=0;t<e.beaconHash.byteLength;t++)r.push(e.beaconHash[t])}if(r.length>0){const a=new Uint8Array(r);await t.writeULE32(a.byteLength),await t.write(a)}else await t.writeULE32(0);async function o(e){a.G1.toRprLEM(n,0,e),await t.write(n)}async function s(e){a.G2.toRprLEM(i,0,e),await t.write(i)}}async function ft(t,a,e){await t.writeULE32(7);const n=t.pos;await t.writeULE64(0),await t.writeULE32(e.length);for(let o=0;o<e.length;o++)await wt(t,a,e[o]);const i=t.pos-n-8,r=t.pos;await t.writeULE64(i,n),t.pos=r}function pt(t,a,e){e&&e.debug("Calculating First Challenge Hash");const n=new m.default(64),i=new Uint8Array(2*t.G1.F.n8),r=new Uint8Array(2*t.G2.F.n8);let o;return t.G1.toRprUncompressed(i,0,t.G1.g),t.G2.toRprUncompressed(r,0,t.G2.g),n.update(m.default(64).digest()),o=2**a*2-1,e&&e.debug("Calculate Initial Hash: tauG1"),s(i,o),o=2**a,e&&e.debug("Calculate Initial Hash: tauG2"),s(r,o),e&&e.debug("Calculate Initial Hash: alphaTauG1"),s(i,o),e&&e.debug("Calculate Initial Hash: betaTauG1"),s(i,o),n.update(r),n.digest();function s(t,a){const i=5e5,r=Math.floor(a/i),o=a%i,s=new Uint8Array(i*t.byteLength);for(let e=0;e<i;e++)s.set(t,e*t.byteLength);for(let c=0;c<r;c++)n.update(s),e&&e.debug("Initial hash: "+c*i);for(let e=0;e<o;e++)n.update(t)}}function gt(t,a,e,n){return rt(t,a,z(e,n))}const mt=U;async function ht(t,a,e,n){let i;if(1==a.type){const i=gt(t,e.nextChallenge,a.beaconHash,a.numIterationsExp);if(!t.G1.eq(a.key.tau.g1_s,i.tau.g1_s))return n&&n.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.tau.g1_sx,i.tau.g1_sx))return n&&n.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G2.eq(a.key.tau.g2_spx,i.tau.g2_spx))return n&&n.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.alpha.g1_s,i.alpha.g1_s))return n&&n.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.alpha.g1_sx,i.alpha.g1_sx))return n&&n.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G2.eq(a.key.alpha.g2_spx,i.alpha.g2_spx))return n&&n.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.beta.g1_s,i.beta.g1_s))return n&&n.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G1.eq(a.key.beta.g1_sx,i.beta.g1_sx))return n&&n.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!t.G2.eq(a.key.beta.g2_spx,i.beta.g2_spx))return n&&n.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1}return a.key.tau.g2_sp=t.G2.toAffine(nt(t,0,e.nextChallenge,a.key.tau.g1_s,a.key.tau.g1_sx)),a.key.alpha.g2_sp=t.G2.toAffine(nt(t,1,e.nextChallenge,a.key.alpha.g1_s,a.key.alpha.g1_sx)),a.key.beta.g2_sp=t.G2.toAffine(nt(t,2,e.nextChallenge,a.key.beta.g1_s,a.key.beta.g1_sx)),i=await mt(t,a.key.tau.g1_s,a.key.tau.g1_sx,a.key.tau.g2_sp,a.key.tau.g2_spx),!0!==i?(n&&n.error("INVALID key (tau) in challenge #"+a.id),!1):(i=await mt(t,a.key.alpha.g1_s,a.key.alpha.g1_sx,a.key.alpha.g2_sp,a.key.alpha.g2_spx),!0!==i?(n&&n.error("INVALID key (alpha) in challenge #"+a.id),!1):(i=await mt(t,a.key.beta.g1_s,a.key.beta.g1_sx,a.key.beta.g2_sp,a.key.beta.g2_spx),!0!==i?(n&&n.error("INVALID key (beta) in challenge #"+a.id),!1):(i=await mt(t,e.tauG1,a.tauG1,a.key.tau.g2_sp,a.key.tau.g2_spx),!0!==i?(n&&n.error("INVALID tau*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await mt(t,a.key.tau.g1_s,a.key.tau.g1_sx,e.tauG2,a.tauG2),!0!==i?(n&&n.error("INVALID tau*G2. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await mt(t,e.alphaG1,a.alphaG1,a.key.alpha.g2_sp,a.key.alpha.g2_spx),!0!==i?(n&&n.error("INVALID alpha*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await mt(t,e.betaG1,a.betaG1,a.key.beta.g2_sp,a.key.beta.g2_spx),!0!==i?(n&&n.error("INVALID beta*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(i=await mt(t,a.key.beta.g1_s,a.key.beta.g1_sx,e.betaG2,a.betaG2),!0!==i?(n&&n.error("INVALID beta*G2. challenge #"+a.id+"It does not follow the previous contribution"),!1):(n&&n.info("Powers Of tau file OK!"),!0))))))))}async function bt(t,a,e,n,i,r,o,s,c,l){const u=i[r],d=2*u.F.n8,w=a[n][0].size/d;await g.startReadUniqueSection(t,a,n),await g.startWriteSection(e,n);let f=o;for(let p=0;p<w;p+=65536){l&&l.debug(`Applying key: ${c}: ${p}/${w}`);const a=Math.min(w-p,65536);let n;n=await t.read(a*d),n=await u.batchApplyKey(n,f,s),await e.write(n),f=i.Fr.mul(f,i.Fr.exp(s,a))}await g.endWriteSection(e),await g.endReadSection(t)}async function yt(t,a,e,n,i,r,o,s,c,l,u){const d=n[i],w=2*d.F.n8,f=Math.floor((1<<20)/w);let p=o;for(let g=0;g<r;g+=f){u&&u.debug(`Applying key ${l}: ${g}/${r}`);const i=Math.min(r-g,f),o=await t.read(i*w),m=await d.batchUtoLEM(o),h=await d.batchApplyKey(m,p,s);let b;b="COMPRESSED"==c?await d.batchLEMtoC(h):await d.batchLEMtoU(h),e&&e.update(b),await a.write(b),p=n.Fr.mul(p,n.Fr.exp(s,i))}}var Gt=Object.freeze({__proto__:null,newAccumulator:async function(t,a,e,n){await m.default.ready();const i=await g.createBinFile(e,"ptau",1,7);await ot(i,t,a,0);const r=t.G1.oneAffine,o=t.G2.oneAffine;await g.startWriteSection(i,2);const s=2**a*2-1;for(let w=0;w<s;w++)await i.write(r),n&&w%1e5==0&&w&&n.log("tauG1: "+w);await g.endWriteSection(i),await g.startWriteSection(i,3);const c=2**a;for(let w=0;w<c;w++)await i.write(o),n&&w%1e5==0&&w&&n.log("tauG2: "+w);await g.endWriteSection(i),await g.startWriteSection(i,4);const l=2**a;for(let w=0;w<l;w++)await i.write(r),n&&w%1e5==0&&w&&n.log("alphaTauG1: "+w);await g.endWriteSection(i),await g.startWriteSection(i,5);const u=2**a;for(let w=0;w<u;w++)await i.write(r),n&&w%1e5==0&&w&&n.log("betaTauG1: "+w);await g.endWriteSection(i),await g.startWriteSection(i,6),await i.write(o),await g.endWriteSection(i),await g.startWriteSection(i,7),await i.writeULE32(0),await g.endWriteSection(i),await i.close();const d=pt(t,a,n);return n&&n.debug(B(m.default(64).digest(),"Blank Contribution Hash:")),n&&n.info(B(d,"First Contribution Hash:")),d},exportChallenge:async function(t,a,e){await m.default.ready();const{fd:n,sections:i}=await g.readBinFile(t,"ptau",1),{curve:r,power:o}=await st(n,i),s=await dt(n,r,i);let c,l;0==s.length?(c=m.default(64).digest(),l=pt(r,o)):(c=s[s.length-1].responseHash,l=s[s.length-1].nextChallenge),e&&e.info(B(c,"Last Response Hash: ")),e&&e.info(B(l,"New Challenge Hash: "));const u=await b.createOverride(a),d=m.default(64);await u.write(c),d.update(c),await f(2,"G1",2**o*2-1,"tauG1"),await f(3,"G2",2**o,"tauG2"),await f(4,"G1",2**o,"alphaTauG1"),await f(5,"G1",2**o,"betaTauG1"),await f(6,"G2",1,"betaG2"),await n.close(),await u.close();const w=d.digest();if(!x(l,w))throw e&&e.info(B(w,"Calc Curret Challenge Hash: ")),e&&e.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return l;async function f(t,a,o,s){const c=r[a],l=2*c.F.n8,w=Math.floor((1<<24)/l);await g.startReadUniqueSection(n,i,t);for(let i=0;i<o;i+=w){e&&e.debug(`Exporting ${s}: ${i}/${o}`);const t=Math.min(o-i,w);let a;a=await n.read(t*l),a=await c.batchLEMtoU(a),await u.write(a),d.update(a)}await g.endReadSection(n)}},importResponse:async function(t,a,e,n,i,r){await m.default.ready();const o=new Uint8Array(64);for(let g=0;g<64;g++)o[g]=255;const{fd:s,sections:c}=await g.readBinFile(t,"ptau",1),{curve:l,power:u}=await st(s,c),d=await dt(s,l,c),w={};n&&(w.name=n);const f=2*l.F1.n8,p=l.F1.n8,h=2*l.F2.n8,y=l.F2.n8,G=await b.readExisting(a);if(G.totalSize!=64+(2**u*2-1)*p+2**u*y+2**u*p+2**u*p+y+6*f+3*h)throw new Error("Size of the contribution is invalid");let S;S=d.length>0?d[d.length-1].nextChallenge:pt(l,u,r);const _=await g.createBinFile(e,"ptau",1,i?7:2);await ot(_,l,u);const v=await G.read(64);if(x(o,S)&&(S=v,d[d.length-1].nextChallenge=S),!x(v,S))throw new Error("Wrong contribution. this contribution is not based on the previus hash");const F=new m.default(64);F.update(v);const E=[];let A;A=await z(G,_,"G1",2,2**u*2-1,[1],"tauG1"),w.tauG1=A[0],A=await z(G,_,"G2",3,2**u,[1],"tauG2"),w.tauG2=A[0],A=await z(G,_,"G1",4,2**u,[0],"alphaG1"),w.alphaG1=A[0],A=await z(G,_,"G1",5,2**u,[0],"betaG1"),w.betaG1=A[0],A=await z(G,_,"G2",6,1,[0],"betaG2"),w.betaG2=A[0],w.partialHash=F.getPartialHash();const U=await G.read(2*l.F1.n8*6+2*l.F2.n8*3);w.key=ct(U,0,l,!1),F.update(new Uint8Array(U));const L=F.digest();if(r&&r.info(B(L,"Contribution Response Hash imported: ")),i){const t=new m.default(64);t.update(L),await R(t,_,"G1",2,2**u*2-1,"tauG1",r),await R(t,_,"G2",3,2**u,"tauG2",r),await R(t,_,"G1",4,2**u,"alphaTauG1",r),await R(t,_,"G1",5,2**u,"betaTauG1",r),await R(t,_,"G2",6,1,"betaG2",r),w.nextChallenge=t.digest(),r&&r.info(B(w.nextChallenge,"Next Challenge Hash: "))}else w.nextChallenge=o;return d.push(w),await ft(_,l,d),await G.close(),await _.close(),await s.close(),w.nextChallenge;async function z(t,a,e,n,o,s,c){return i?await async function(t,a,e,n,i,o,s){const c=l[e],u=c.F.n8,d=2*c.F.n8,w=[];await g.startWriteSection(a,n);const f=Math.floor((1<<24)/d);E[n]=a.pos;for(let l=0;l<i;l+=f){r&&r.debug(`Importing ${s}: ${l}/${i}`);const e=Math.min(i-l,f),n=await t.read(e*u);F.update(n);const p=await c.batchCtoLEM(n);await a.write(p);for(let t=0;t<o.length;t++){const a=o[t];if(a>=l&&a<l+e){const t=c.fromRprLEM(p,(a-l)*d);w.push(t)}}}return await g.endWriteSection(a),w}(t,a,e,n,o,s,c):await async function(t,a,e,n,i,o,s){const c=l[e],u=c.F.n8,d=[],w=Math.floor((1<<24)/u);for(let l=0;l<i;l+=w){r&&r.debug(`Importing ${s}: ${l}/${i}`);const a=Math.min(i-l,w),e=await t.read(a*u);F.update(e);for(let t=0;t<o.length;t++){const n=o[t];if(n>=l&&n<l+a){const t=c.fromRprCompressed(e,(n-l)*u);d.push(t)}}}return d}(t,0,e,0,o,s,c)}async function R(t,a,e,n,i,r,o){const s=l[e],c=2*s.F.n8,u=Math.floor((1<<24)/c),d=a.pos;a.pos=E[n];for(let l=0;l<i;l+=u){o&&o.debug(`Hashing ${r}: ${l}/${i}`);const e=Math.min(i-l,u),n=await a.read(e*c),d=await s.batchLEMtoU(n);t.update(d)}a.pos=d}},verify:async function(t,a){let e;await m.default.ready();const{fd:n,sections:i}=await g.readBinFile(t,"ptau",1),{curve:o,power:s,ceremonyPower:c}=await st(n,i),l=await dt(n,o,i);a&&a.debug("power: 2**"+s),a&&a.debug("Computing initial contribution hash");const u={tauG1:o.G1.g,tauG2:o.G2.g,alphaG1:o.G1.g,betaG1:o.G1.g,betaG2:o.G2.g,nextChallenge:pt(o,c,a),responseHash:m.default(64).digest()};if(0==l.length)return a&&a.error("This file has no contribution! It cannot be used in production"),!1;let d;d=l.length>1?l[l.length-2]:u;const w=l[l.length-1];if(a&&a.debug("Validating contribution #"+l[l.length-1].id),!(await ht(o,w,d,a)))return!1;const f=m.default(64);f.update(w.responseHash),a&&a.debug("Verifying powers in tau*G1 section");const p=await F(2,"G1","tauG1",2**s*2-1,[0,1],a);if(e=await mt(o,p.R1,p.R2,o.G2.g,w.tauG2),!0!==e)return a&&a.error("tauG1 section. Powers do not match"),!1;if(!o.G1.eq(o.G1.g,p.singularPoints[0]))return a&&a.error("First element of tau*G1 section must be the generator"),!1;if(!o.G1.eq(w.tauG1,p.singularPoints[1]))return a&&a.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in tau*G2 section");const b=await F(3,"G2","tauG2",2**s,[0,1],a);if(e=await mt(o,o.G1.g,w.tauG1,b.R1,b.R2),!0!==e)return a&&a.error("tauG2 section. Powers do not match"),!1;if(!o.G2.eq(o.G2.g,b.singularPoints[0]))return a&&a.error("First element of tau*G2 section must be the generator"),!1;if(!o.G2.eq(w.tauG2,b.singularPoints[1]))return a&&a.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in alpha*tau*G1 section");const y=await F(4,"G1","alphatauG1",2**s,[0],a);if(e=await mt(o,y.R1,y.R2,o.G2.g,w.tauG2),!0!==e)return a&&a.error("alphaTauG1 section. Powers do not match"),!1;if(!o.G1.eq(w.alphaG1,y.singularPoints[0]))return a&&a.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in beta*tau*G1 section");const G=await F(5,"G1","betatauG1",2**s,[0],a);if(e=await mt(o,G.R1,G.R2,o.G2.g,w.tauG2),!0!==e)return a&&a.error("betaTauG1 section. Powers do not match"),!1;if(!o.G1.eq(w.betaG1,G.singularPoints[0]))return a&&a.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;const S=await async function(t){const a=o.G2,e=2*a.F.n8,r=new Uint8Array(e);if(!i[6])throw t.error("File has no BetaG2 section"),new Error("File has no BetaG2 section");if(i[6].length>1)throw t.error("File has no BetaG2 section"),new Error("File has more than one GetaG2 section");n.pos=i[6][0].p;const s=await n.read(e),c=a.fromRprLEM(s);return a.toRprUncompressed(r,0,c),f.update(r),c}(a);if(!o.G2.eq(w.betaG2,S))return a&&a.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;const _=f.digest();if(s==c&&!x(_,w.nextChallenge))return a&&a.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;a&&a.info(B(_,"Next challenge hash: ")),v(w,d);for(let r=l.length-2;r>=0;r--){const t=l[r],e=r>0?l[r-1]:u;if(!(await ht(o,t,e,a)))return!1;v(t,e)}if(a&&a.info("-----------------------------------------------------"),i[12]&&i[13]&&i[14]&&i[15]){let t;if(t=await E("G1",2,12,"tauG1",a),!t)return!1;if(t=await E("G2",3,13,"tauG2",a),!t)return!1;if(t=await E("G1",4,14,"alphaTauG1",a),!t)return!1;if(t=await E("G1",5,15,"betaTauG1",a),!t)return!1}else a&&a.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await n.close(),a&&a.info("Powers of Tau Ok!"),!0;function v(t,e){if(!a)return;a.info("-----------------------------------------------------"),a.info(`Contribution #${t.id}: ${t.name||""}`),a.info(B(t.nextChallenge,"Next Challenge: "));const n=new Uint8Array(2*o.G1.F.n8*6+2*o.G2.F.n8*3);lt(n,0,o,t.key,!1);const i=m.default(64);i.setPartialHash(t.partialHash),i.update(n);const r=i.digest();a.info(B(r,"Response Hash:")),a.info(B(e.nextChallenge,"Response Hash:")),1==t.type&&(a.info(`Beacon generator: ${k(t.beaconHash)}`),a.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}async function F(t,a,e,r,s,c){const l=o[a],u=2*l.F.n8;await g.startReadUniqueSection(n,i,t);const d=[];let w=l.zero,p=l.zero,m=l.zero;for(let i=0;i<r;i+=65536){c&&c.debug(`points relations: ${e}: ${i}/${r} `);const t=Math.min(r-i,65536),a=await n.read(t*u),o=await l.batchLEMtoU(a);f.update(o);const g=new Uint8Array(4*(t-1));if(h.default.randomFillSync(g),i>0){const t=l.fromRprLEM(a,0),e=h.default.randomBytes(4).readUInt32BE(0,!0);w=l.add(w,l.timesScalar(m,e)),p=l.add(p,l.timesScalar(t,e))}const b=await l.multiExpAffine(a.slice(0,(t-1)*u),g),y=await l.multiExpAffine(a.slice(u),g);w=l.add(w,b),p=l.add(p,y),m=l.fromRprLEM(a,(t-1)*u);for(let e=0;e<s.length;e++){const n=s[e];if(n>=i&&n<i+t){const t=l.fromRprLEM(a,(n-i)*u);d.push(t)}}}return await g.endReadSection(n),{R1:w,R2:p,singularPoints:d}}async function E(t,a,e,c,l){l&&l.debug(`Verifying phase2 calculated values ${c}...`);const u=o[t],d=2*u.F.n8,w=new Array(8);for(let n=0;n<8;n++)w[n]=h.default.randomBytes(4).readUInt32BE(0,!0);for(let n=0;n<=s;n++){if(!(await f(n)))return!1}if(2==a){if(!(await f(s+1)))return!1}return!0;async function f(t){l&&l.debug(`Power ${t}...`);const f=o.Fr.n8,p=2**t;let m,h=new Uint32Array(p),b=new r.ChaCha(w);l&&l.debug(`Creating random numbers Powers${t}...`);for(let a=0;a<p;a++)h[a]=t==s+1&&a==p-1?0:b.nextU32();h=new Uint8Array(h.buffer,h.byteOffset,h.byteLength),l&&l.debug(`reading points Powers${t}...`),await g.startReadUniqueSection(n,i,a),m=new r.BigBuffer(p*d),t==s+1?(await n.readToBuffer(m,0,(p-1)*d),m.set(o.G1.zeroAffine,(p-1)*d)):await n.readToBuffer(m,0,p*d),await g.endReadSection(n,!0);const y=await u.multiExpAffine(m,h,l,c+"_"+t);h=new r.BigBuffer(p*f),b=new r.ChaCha(w);const G=new Uint8Array(4),S=new DataView(G.buffer);l&&l.debug(`Creating random numbers Powers${t}...`);for(let a=0;a<p;a++)a==p-1&&t==s+1||(S.setUint32(0,b.nextU32(),!0),h.set(G,a*f));l&&l.debug(`batchToMontgomery ${t}...`),h=await o.Fr.batchToMontgomery(h),l&&l.debug(`fft ${t}...`),h=await o.Fr.fft(h),l&&l.debug(`batchFromMontgomery ${t}...`),h=await o.Fr.batchFromMontgomery(h),l&&l.debug(`reading points Lagrange${t}...`),await g.startReadUniqueSection(n,i,e),n.pos+=d*(2**t-1),await n.readToBuffer(m,0,p*d),await g.endReadSection(n,!0);const _=await u.multiExpAffine(m,h,l,c+"_"+t+"_transformed");return!!u.eq(y,_)||(l&&l.error("Phase2 caclutation does not match with powers of tau"),!1)}}},challengeContribute:async function(t,a,e,n,i){await m.default.ready();const r=await b.readExisting(a),o=8*t.F1.n64*2,s=8*t.F2.n64*2,c=(r.totalSize+o-64-s)/(4*o+s);let l=c,u=0;for(;l>1;)l/=2,u+=1;if(2**u!=c)throw new Error("Invalid file size");i&&i.debug("Power to tau size: "+u);const d=await L(n),w=await b.createOverride(e),f=m.default(64);for(let m=0;m<r.totalSize;m+=r.pageSize){i&&i.debug(`Hashing challenge ${m}/${r.totalSize}`);const t=Math.min(r.totalSize-m,r.pageSize),a=await r.read(t);f.update(a)}const p=await r.read(64,0);i&&i.info(B(p,"Claimed Previous Response Hash: "));const g=f.digest();i&&i.info(B(g,"Current Challenge Hash: "));const h=rt(t,g,d);i&&["tau","alpha","beta"].forEach((a=>{i.debug(a+".g1_s: "+t.G1.toString(h[a].g1_s,16)),i.debug(a+".g1_sx: "+t.G1.toString(h[a].g1_sx,16)),i.debug(a+".g2_sp: "+t.G2.toString(h[a].g2_sp,16)),i.debug(a+".g2_spx: "+t.G2.toString(h[a].g2_spx,16)),i.debug("")}));const y=m.default(64);await w.write(g),y.update(g),await yt(r,w,y,t,"G1",2**u*2-1,t.Fr.one,h.tau.prvKey,"COMPRESSED","tauG1",i),await yt(r,w,y,t,"G2",2**u,t.Fr.one,h.tau.prvKey,"COMPRESSED","tauG2",i),await yt(r,w,y,t,"G1",2**u,h.alpha.prvKey,h.tau.prvKey,"COMPRESSED","alphaTauG1",i),await yt(r,w,y,t,"G1",2**u,h.beta.prvKey,h.tau.prvKey,"COMPRESSED","betaTauG1",i),await yt(r,w,y,t,"G2",1,h.beta.prvKey,h.tau.prvKey,"COMPRESSED","betaTauG2",i);const G=new Uint8Array(2*t.F1.n8*6+2*t.F2.n8*3);lt(G,0,t,h,!1),await w.write(G),y.update(G);const S=y.digest();i&&i.info(B(S,"Contribution Response Hash: ")),await w.close(),await r.close()},beacon:async function(t,a,e,n,i,r){const o=R(n);if(0==o.byteLength||2*o.byteLength!=n.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((i=parseInt(i))<10||i>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await m.default.ready();const{fd:s,sections:c}=await g.readBinFile(t,"ptau",1),{curve:l,power:u,ceremonyPower:d}=await st(s,c);if(u!=d)return r&&r.error("This file has been reduced. You cannot contribute into a reduced file."),!1;c[12]&&r&&r.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const w=await dt(s,l,c),f={name:e,type:1,numIterationsExp:i,beaconHash:o};let p;p=w.length>0?w[w.length-1].nextChallenge:pt(l,u,r),f.key=gt(l,p,o,i);const h=new m.default(64);h.update(p);const b=await g.createBinFile(a,"ptau",1,7);await ot(b,l,u);const y=[];let G;G=await F(2,"G1",2**u*2-1,l.Fr.e(1),f.key.tau.prvKey,"tauG1",r),f.tauG1=G[1],G=await F(3,"G2",2**u,l.Fr.e(1),f.key.tau.prvKey,"tauG2",r),f.tauG2=G[1],G=await F(4,"G1",2**u,f.key.alpha.prvKey,f.key.tau.prvKey,"alphaTauG1",r),f.alphaG1=G[0],G=await F(5,"G1",2**u,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG1",r),f.betaG1=G[0],G=await F(6,"G2",1,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG2",r),f.betaG2=G[0],f.partialHash=h.getPartialHash();const S=new Uint8Array(2*l.F1.n8*6+2*l.F2.n8*3);lt(S,0,l,f.key,!1),h.update(new Uint8Array(S));const _=h.digest();r&&r.info(B(_,"Contribution Response Hash imported: "));const v=new m.default(64);return v.update(_),await E(b,"G1",2,2**u*2-1,"tauG1",r),await E(b,"G2",3,2**u,"tauG2",r),await E(b,"G1",4,2**u,"alphaTauG1",r),await E(b,"G1",5,2**u,"betaTauG1",r),await E(b,"G2",6,1,"betaG2",r),f.nextChallenge=v.digest(),r&&r.info(B(f.nextChallenge,"Next Challenge Hash: ")),w.push(f),await ft(b,l,w),await s.close(),await b.close(),_;async function F(t,a,e,n,i,r,o){const u=[];s.pos=c[t][0].p,await g.startWriteSection(b,t),y[t]=b.pos;const d=l[a],w=2*d.F.n8,f=Math.floor((1<<20)/w);let p=n;for(let c=0;c<e;c+=f){o&&o.debug(`applying key${r}: ${c}/${e}`);const t=Math.min(e-c,f),a=await s.read(t*w),n=await d.batchApplyKey(a,p,i),g=b.write(n),m=await d.batchLEMtoC(n);if(h.update(m),await g,0==c)for(let i=0;i<Math.min(2,e);i++)u.push(d.fromRprLEM(n,i*w));p=l.Fr.mul(p,l.Fr.exp(i,t))}return await g.endWriteSection(b),u}async function E(t,a,e,n,i,r){const o=l[a],s=2*o.F.n8,c=Math.floor((1<<24)/s),u=t.pos;t.pos=y[e];for(let l=0;l<n;l+=c){r&&r.debug(`Hashing ${i}: ${l}/${n}`);const a=Math.min(n-l,c),e=await t.read(a*s),u=await o.batchLEMtoU(e);v.update(u)}t.pos=u}},contribute:async function(t,a,e,n,i){await m.default.ready();const{fd:r,sections:o}=await g.readBinFile(t,"ptau",1),{curve:s,power:c,ceremonyPower:l}=await st(r,o);if(c!=l)throw i&&i.error("This file has been reduced. You cannot contribute into a reduced file."),new Error("This file has been reduced. You cannot contribute into a reduced file.");o[12]&&i&&i.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const u=await dt(r,s,o),d={name:e,type:0};let w;const f=await L(n);w=u.length>0?u[u.length-1].nextChallenge:pt(s,c,i),d.key=rt(s,w,f);const p=new m.default(64);p.update(w);const h=await g.createBinFile(a,"ptau",1,7);await ot(h,s,c);const b=[];let y;y=await v(2,"G1",2**c*2-1,s.Fr.e(1),d.key.tau.prvKey,"tauG1"),d.tauG1=y[1],y=await v(3,"G2",2**c,s.Fr.e(1),d.key.tau.prvKey,"tauG2"),d.tauG2=y[1],y=await v(4,"G1",2**c,d.key.alpha.prvKey,d.key.tau.prvKey,"alphaTauG1"),d.alphaG1=y[0],y=await v(5,"G1",2**c,d.key.beta.prvKey,d.key.tau.prvKey,"betaTauG1"),d.betaG1=y[0],y=await v(6,"G2",1,d.key.beta.prvKey,d.key.tau.prvKey,"betaTauG2"),d.betaG2=y[0],d.partialHash=p.getPartialHash();const G=new Uint8Array(2*s.F1.n8*6+2*s.F2.n8*3);lt(G,0,s,d.key,!1),p.update(new Uint8Array(G));const S=p.digest();i&&i.info(B(S,"Contribution Response Hash imported: "));const _=new m.default(64);return _.update(S),await F(h,"G1",2,2**c*2-1,"tauG1"),await F(h,"G2",3,2**c,"tauG2"),await F(h,"G1",4,2**c,"alphaTauG1"),await F(h,"G1",5,2**c,"betaTauG1"),await F(h,"G2",6,1,"betaG2"),d.nextChallenge=_.digest(),i&&i.info(B(d.nextChallenge,"Next Challenge Hash: ")),u.push(d),await ft(h,s,u),await r.close(),await h.close(),S;async function v(t,a,e,n,c,l){const u=[];r.pos=o[t][0].p,await g.startWriteSection(h,t),b[t]=h.pos;const d=s[a],w=2*d.F.n8,f=Math.floor((1<<20)/w);let m=n;for(let o=0;o<e;o+=f){i&&i.debug(`processing: ${l}: ${o}/${e}`);const t=Math.min(e-o,f),a=await r.read(t*w),n=await d.batchApplyKey(a,m,c),g=h.write(n),b=await d.batchLEMtoC(n);if(p.update(b),await g,0==o)for(let i=0;i<Math.min(2,e);i++)u.push(d.fromRprLEM(n,i*w));m=s.Fr.mul(m,s.Fr.exp(c,t))}return await g.endWriteSection(h),u}async function F(t,a,e,n,r){const o=s[a],c=2*o.F.n8,l=Math.floor((1<<24)/c),u=t.pos;t.pos=b[e];for(let s=0;s<n;s+=l){i&&s&&i.debug(`Hashing ${r}: `+s);const a=Math.min(n-s,l),e=await t.read(a*c),u=await o.batchLEMtoU(e);_.update(u)}t.pos=u}},preparePhase2:async function(t,a,e){const{fd:n,sections:i}=await g.readBinFile(t,"ptau",1),{curve:o,power:s}=await st(n,i),c=await g.createBinFile(a,"ptau",1,11);return await ot(c,o,s),await g.copySection(n,i,c,2),await g.copySection(n,i,c,3),await g.copySection(n,i,c,4),await g.copySection(n,i,c,5),await g.copySection(n,i,c,6),await g.copySection(n,i,c,7),await l(2,12,"G1","tauG1"),await l(3,13,"G2","tauG2"),await l(4,14,"G1","alphaTauG1"),await l(5,15,"G1","betaTauG1"),await n.close(),void(await c.close());async function l(t,a,l,u){e&&e.debug("Starting section: "+u),await g.startWriteSection(c,a);for(let e=0;e<=s;e++)await d(e);async function d(a){const d=2**a,w=o[l];o.Fr;const f=2*w.F.n8;let p;w.F.n8,p=new r.BigBuffer(d*f),await g.startReadUniqueSection(n,i,t),2==t&&a==s+1?(await n.readToBuffer(p,0,(d-1)*f),p.set(o.G1.zeroAffine,(d-1)*f)):await n.readToBuffer(p,0,d*f),await g.endReadSection(n,!0),p=await w.lagrangeEvaluations(p,"affine","affine",e,u),await c.write(p)}2==t&&await d(s+1),await g.endWriteSection(c)}},truncate:async function(t,a,e){const{fd:n,sections:i}=await g.readBinFile(t,"ptau",1),{curve:r,power:o,ceremonyPower:s}=await st(n,i),c=2*r.G1.F.n8,l=2*r.G2.F.n8;for(let d=1;d<o;d++)await u(d);return await n.close(),!0;async function u(t){let o=t.toString();for(;o.length<2;)o="0"+o;e&&e.debug("Writing Power: "+o);const u=await g.createBinFile(a+o+".ptau","ptau",1,11);await ot(u,r,t,s),await g.copySection(n,i,u,2,(2**t*2-1)*c),await g.copySection(n,i,u,3,2**t*l),await g.copySection(n,i,u,4,2**t*c),await g.copySection(n,i,u,5,2**t*c),await g.copySection(n,i,u,6,l),await g.copySection(n,i,u,7),await g.copySection(n,i,u,12,(2**(t+1)*2-1)*c),await g.copySection(n,i,u,13,(2**t*2-1)*l),await g.copySection(n,i,u,14,(2**t*2-1)*c),await g.copySection(n,i,u,15,(2**t*2-1)*c),await u.close()}},convert:async function(t,a,e){const{fd:n,sections:i}=await g.readBinFile(t,"ptau",1),{curve:o,power:s}=await st(n,i),c=await g.createBinFile(a,"ptau",1,11);return await ot(c,o,s),await g.copySection(n,i,c,2),await g.copySection(n,i,c,3),await g.copySection(n,i,c,4),await g.copySection(n,i,c,5),await g.copySection(n,i,c,6),await g.copySection(n,i,c,7),await async function(t,a,l,u){e&&e.debug("Starting section: "+u);await g.startWriteSection(c,a);const d=i[a][0].size,w=n.pageSize;await g.startReadUniqueSection(n,i,a);for(let e=0;e<d;e+=w){const t=Math.min(d-e,w),a=await n.read(t);await c.write(a)}await g.endReadSection(n),2==t&&await async function(a){const d=2**a,w=o[l],f=2*w.F.n8;let p;p=new r.BigBuffer(d*f),await g.startReadUniqueSection(n,i,t),2==t&&a==s+1?(await n.readToBuffer(p,0,(d-1)*f),p.set(o.G1.zeroAffine,(d-1)*f)):await n.readToBuffer(p,0,d*f);await g.endReadSection(n,!0),p=await w.lagrangeEvaluations(p,"affine","affine",e,u),await c.write(p)}(s+1);await g.endWriteSection(c)}(2,12,"G1","tauG1"),await g.copySection(n,i,c,13),await g.copySection(n,i,c,14),await g.copySection(n,i,c,15),await n.close(),void(await c.close())},exportJson:async function(t,a){const{fd:e,sections:n}=await g.readBinFile(t,"ptau",1),{curve:i,power:r}=await st(e,n),o={};return o.q=i.q,o.power=r,o.contributions=await dt(e,i,n),o.tauG1=await s(2,"G1",2**r*2-1,"tauG1"),o.tauG2=await s(3,"G2",2**r,"tauG2"),o.alphaTauG1=await s(4,"G1",2**r,"alphaTauG1"),o.betaTauG1=await s(5,"G1",2**r,"betaTauG1"),o.betaG2=await s(6,"G2",1,"betaG2"),o.lTauG1=await c(12,"G1","lTauG1"),o.lTauG2=await c(13,"G2","lTauG2"),o.lAlphaTauG1=await c(14,"G1","lAlphaTauG2"),o.lBetaTauG1=await c(15,"G1","lBetaTauG2"),await e.close(),o;async function s(t,r,o,s){const c=i[r],l=2*c.F.n8,u=[];await g.startReadUniqueSection(e,n,t);for(let n=0;n<o;n++){a&&n&&n%1e4==0&&console.log(`${s}: `+n);const t=await e.read(l);u.push(c.fromRprLEM(t,0))}return await g.endReadSection(e),u}async function c(t,o,s){const c=i[o],l=2*c.F.n8,u=[];await g.startReadUniqueSection(e,n,t);for(let n=0;n<=r;n++){a&&console.log(`${s}: Power: ${n}`),u[n]=[];const t=2**n;for(let i=0;i<t;i++){a&&i&&i%1e4==0&&console.log(`${s}: ${i}/${t}`);const r=await e.read(l);u[n].push(c.fromRprLEM(r,0))}}return await g.endReadSection(e),u}}});const St=r.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),_t=r.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");function vt(t,a){if(a instanceof Uint8Array)return t.toString(a);if(Array.isArray(a))return a.map(vt.bind(null,t));if("object"==typeof a){const e={};return Object.keys(a).forEach((n=>{e[n]=vt(t,a[n])})),e}return"bigint"==typeof a||void 0!==a.eq?a.toString(10):a}var Ft=Object.freeze({__proto__:null,print:function(t,a,e){for(let i=0;i<t.constraints.length;i++)n(t.constraints[i]);function n(n){const i=e=>{let n="";return Object.keys(e).forEach((i=>{let r=a.varIdx2Name[i];"one"==r&&(r="");let o=t.curve.Fr.toString(e[i]);"1"==o&&(o=""),"-1"==o&&(o="-"),""!=n&&"-"!=o[0]&&(o="+"+o),""!=n&&(o=" "+o),n=n+o+r})),n},r=`[ ${i(n[0])} ] * [ ${i(n[1])} ] - [ ${i(n[2])} ] = 0`;e&&e.info(r)}},info:async function(t,a){const e=await u.readR1cs(t);return r.Scalar.eq(e.prime,_t)?a&&a.info("Curve: bn-128"):r.Scalar.eq(e.prime,St)?a&&a.info("Curve: bls12-381"):a&&a.info(`Unknown Curve. Prime: ${r.Scalar.toString(e.prime)}`),a&&a.info(`# of Wires: ${e.nVars}`),a&&a.info(`# of Constraints: ${e.nConstraints}`),a&&a.info(`# of Private Inputs: ${e.nPrvInputs}`),a&&a.info(`# of Public Inputs: ${e.nPubInputs}`),a&&a.info(`# of Labels: ${e.nLabels}`),a&&a.info(`# of Outputs: ${e.nOutputs}`),e},exportJson:async function(t,a){const e=await u.readR1cs(t,!0,!0,!0,a),n=e.curve.Fr;return delete e.curve,delete e.F,vt(n,e)}});async function Et(t){const a={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},e=await b.readExisting(t),n=await e.read(e.totalSize),i=new TextDecoder("utf-8").decode(n).split("\n");for(let o=0;o<i.length;o++){const t=i[o].split(",");4==t.length&&(a.varIdx2Name[t[1]]?a.varIdx2Name[t[1]]+="|"+t[3]:a.varIdx2Name[t[1]]=t[3],a.labelIdx2Name[t[0]]=t[3],a.componentIdx2Name[t[2]]||(a.componentIdx2Name[t[2]]=r(t[3])))}return await e.close(),a;function r(t){const a=t.split(".");return a.pop(),a.join(".")}}const{unstringifyBigInts:Bt}=r.utils;var xt=Object.freeze({__proto__:null,calculate:Z,debug:async function(t,a,e,n,i,o){const s=Bt(t),c=await b.readExisting(a),u=await c.read(c.totalSize);await c.close();let d={sanityCheck:!0},w=await Et(n);i.set&&(w||(w=await Et(n)),d.logSetSignal=function(t,a){o&&o.info("SET "+w.labelIdx2Name[t]+" <-- "+a.toString())}),i.get&&(w||(w=await Et(n)),d.logGetSignal=function(t,a){o&&o.info("GET "+w.labelIdx2Name[t]+" --\x3e "+a.toString())}),i.trigger&&(w||(w=await Et(n)),d.logStartComponent=function(t){o&&o.info("START: "+w.componentIdx2Name[t])},d.logFinishComponent=function(t){o&&o.info("FINISH: "+w.componentIdx2Name[t])}),d.sym=w;const f=await l.WitnessCalculatorBuilder(u,d),p=await f.calculateWitness(s),m=await g.createBinFile(e,"wtns",2,2);await async function(t,a,e){await g.startWriteSection(t,1);const n=8*(Math.floor((r.Scalar.bitLength(e)-1)/64)+1);await t.writeULE32(n),await g.writeBigInt(t,e,n),await t.writeULE32(a.length),await g.endWriteSection(t),await g.startWriteSection(t,2);for(let i=0;i<a.length;i++)await g.writeBigInt(t,a[i],n);await g.endWriteSection(t,2)}(m,p,f.prime),await m.close()},exportJson:async function(t){return await async function(t){const{fd:a,sections:e}=await g.readBinFile(t,"wtns",2),{n8:n,nWitness:i}=await N(a,e);await g.startReadUniqueSection(a,e,2);const r=[];for(let o=0;o<i;o++){const t=await g.readBigInt(a,n);r.push(t)}return await g.endReadSection(a),await a.close(),r}(t)}});const At=262144,Ut={get:function(t,a){return isNaN(a)?t[a]:t.getElement(a)},set:function(t,a,e){return isNaN(a)?(t[a]=e,!0):t.setElement(a,e)}};class Lt{constructor(t){this.length=t||0,this.arr=new Array(At);for(let a=0;a<t;a+=At)this.arr[a/At]=new Array(Math.min(At,t-a));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,a){const e=new Array(a-t);for(let n=t;n<a;n++)e[n-t]=this.getElement(n);return e}getElement(t){t=parseInt(t);const a=Math.floor(t/At),e=t%At;return this.arr[a]?this.arr[a][e]:void 0}setElement(t,a){t=parseInt(t);const e=Math.floor(t/At);this.arr[e]||(this.arr[e]=new Array(At));const n=t%At;return this.arr[e][n]=a,t>=this.length&&(this.length=t+1),!0}getKeys(){const t=new zt;for(let a=0;a<this.arr.length;a++)if(this.arr[a])for(let e=0;e<this.arr[a].length;e++)"undefined"!==typeof this.arr[a][e]&&t.push(a*At+e);return t}}class zt{constructor(t){const a=new Lt(t);return new Proxy(a,Ut)}}async function Rt(t,a,e,n){await m.default.ready();const o=m.default(64),{fd:s,sections:c}=await i.readBinFile(a,"ptau",1,1<<22,1<<24),{curve:l,power:d}=await st(s,c),{fd:w,sections:f}=await i.readBinFile(t,"r1cs",1,1<<22,1<<24),p=await u.readR1csHeader(w,f,!1),g=await i.createBinFile(e,"zkey",1,10,1<<22,1<<24),h=2*l.G1.F.n8,b=2*l.G2.F.n8;if(p.prime!=l.r)return n&&n.error("r1cs curve does not match powers of tau ceremony curve"),-1;const y=E(p.nConstraints+p.nPubInputs+p.nOutputs+1-1)+1;if(y>d)return n&&n.error(`circuit too big for this power of tau ceremony. ${p.nConstraints}*2 > 2**${d}`),-1;if(!c[12])return n&&n.error("Powers of tau is not prepared."),-1;const G=p.nOutputs+p.nPubInputs,S=2**y;await i.startWriteSection(g,1),await g.writeULE32(1),await i.endWriteSection(g),await i.startWriteSection(g,2);const _=l.q,v=8*(Math.floor((r.Scalar.bitLength(_)-1)/64)+1),F=l.r,x=8*(Math.floor((r.Scalar.bitLength(F)-1)/64)+1),A=r.Scalar.mod(r.Scalar.shl(1,8*x),F),U=l.Fr.e(r.Scalar.mod(r.Scalar.mul(A,A),F));let L,z,R;await g.writeULE32(v),await i.writeBigInt(g,_,v),await g.writeULE32(x),await i.writeBigInt(g,F,x),await g.writeULE32(p.nVars),await g.writeULE32(G),await g.writeULE32(S),L=await s.read(h,c[4][0].p),await g.write(L),L=await l.G1.batchLEMtoU(L),o.update(L),z=await s.read(h,c[5][0].p),await g.write(z),z=await l.G1.batchLEMtoU(z),o.update(z),R=await s.read(b,c[6][0].p),await g.write(R),R=await l.G2.batchLEMtoU(R),o.update(R);const k=new Uint8Array(h);l.G1.toRprLEM(k,0,l.G1.g);const T=new Uint8Array(b);l.G2.toRprLEM(T,0,l.G2.g);const C=new Uint8Array(h);l.G1.toRprUncompressed(C,0,l.G1.g);const I=new Uint8Array(b);l.G2.toRprUncompressed(I,0,l.G2.g),await g.write(T),await g.write(k),await g.write(T),o.update(I),o.update(C),o.update(I),await i.endWriteSection(g),n&&n.info("Reading r1cs");let $=await i.readSection(w,f,2);const O=new zt(p.nVars),M=new zt(p.nVars),P=new zt(p.nVars),q=new zt(p.nVars-G-1),W=new Array(G+1);n&&n.info("Reading tauG1");let j=await i.readSection(s,c,12,(S-1)*h,S*h);n&&n.info("Reading tauG2");let H=await i.readSection(s,c,13,(S-1)*b,S*b);n&&n.info("Reading alphatauG1");let V=await i.readSection(s,c,14,(S-1)*h,S*h);n&&n.info("Reading betatauG1");let N=await i.readSection(s,c,15,(S-1)*h,S*h);await async function(){const t=new Uint8Array(12+l.Fr.n8),a=new DataView(t.buffer),e=new Uint8Array(l.Fr.n8);l.Fr.toRprLE(e,0,l.Fr.e(1));let o=0;function s(){const t=$.slice(o,o+4);o+=4;return new DataView(t.buffer).getUint32(0,!0)}const c=new zt;for(let i=0;i<p.nConstraints;i++){n&&i%1e4==0&&n.debug(`processing constraints: ${i}/${p.nConstraints}`);const t=s();for(let n=0;n<t;n++){const t=s(),a=o;o+=l.Fr.n8;const e=0,n=h*i,r=3,u=h*i;"undefined"===typeof O[t]&&(O[t]=[]),O[t].push([e,n,a]),t<=G?("undefined"===typeof W[t]&&(W[t]=[]),W[t].push([r,u,a])):("undefined"===typeof q[t-G-1]&&(q[t-G-1]=[]),q[t-G-1].push([r,u,a])),c.push([0,i,t,a])}const a=s();for(let n=0;n<a;n++){const t=s(),a=o;o+=l.Fr.n8;const e=0,n=h*i,r=1,u=b*i,d=2,w=h*i;"undefined"===typeof M[t]&&(M[t]=[]),M[t].push([e,n,a]),"undefined"===typeof P[t]&&(P[t]=[]),P[t].push([r,u,a]),t<=G?("undefined"===typeof W[t]&&(W[t]=[]),W[t].push([d,w,a])):("undefined"===typeof q[t-G-1]&&(q[t-G-1]=[]),q[t-G-1].push([d,w,a])),c.push([1,i,t,a])}const e=s();for(let n=0;n<e;n++){const t=s(),a=o;o+=l.Fr.n8;const e=0,n=h*i;t<=G?("undefined"===typeof W[t]&&(W[t]=[]),W[t].push([e,n,a])):("undefined"===typeof q[t-G-1]&&(q[t-G-1]=[]),q[t-G-1].push([e,n,a]))}}for(let n=0;n<=G;n++){const t=0,a=h*(p.nConstraints+n),e=3,i=h*(p.nConstraints+n);"undefined"===typeof O[n]&&(O[n]=[]),O[n].push([t,a,-1]),"undefined"===typeof W[n]&&(W[n]=[]),W[n].push([e,i,-1]),c.push([0,p.nConstraints+n,n,-1])}await i.startWriteSection(g,4);const u=new r.BigBuffer(c.length*(12+l.Fr.n8)+4),d=new Uint8Array(4);new DataView(d.buffer).setUint32(0,c.length,!0),u.set(d);let w=4;for(let i=0;i<c.length;i++)n&&i%1e5==0&&n.debug(`writing coeffs: ${i}/${c.length}`),f(c[i]);function f(n){let i;a.setUint32(0,n[0],!0),a.setUint32(4,n[1],!0),a.setUint32(8,n[2],!0),i=n[3]>=0?l.Fr.fromRprLE($.slice(n[3],n[3]+l.Fr.n8),0):l.Fr.fromRprLE(e,0);const r=l.Fr.mul(i,U);l.Fr.toRprLE(t,12,r),u.set(t,w),w+=t.length}await g.write(u),await i.endWriteSection(g)}(),await D(3,"G1",W,"IC"),await async function(){await i.startWriteSection(g,9);const t=new r.BigBuffer(S*h);if(y<l.Fr.s){let a=await i.readSection(s,c,12,(2*S-1)*h,2*S*h);for(let e=0;e<S;e++){n&&e%1e4==0&&n.debug(`spliting buffer: ${e}/${S}`);const i=a.slice((2*e+1)*h,(2*e+1)*h+h);t.set(i,e*h)}}else{if(y!=l.Fr.s)throw n&&n.error("Circuit too big"),new Error("Circuit too big for this curve");{const a=c[12][0].p+(2**(y+1)-1)*h;await s.readToBuffer(t,0,S*h,a+S*h)}}await g.write(t),await i.endWriteSection(g)}(),await async function(){X(S-1);for(let t=0;t<S-1;t+=16384){n&&n.debug(`HashingHPoints: ${t}/${S}`);const a=Math.min(S-1,16384);await Z(t,a)}}(),await D(8,"G1",q,"C"),await D(5,"G1",O,"A"),await D(6,"G1",M,"B1"),await D(7,"G2",P,"B2");const K=o.digest();return await i.startWriteSection(g,10),await g.write(K),await g.writeULE32(0),await i.endWriteSection(g),n&&n.info(B(K,"Circuit hash: ")),await g.close(),await w.close(),await s.close(),K;async function D(t,a,e,r){const s=l[a];X(e.length),await i.startWriteSection(g,t);let c=[],u=0;for(;u<e.length;){let t=0;for(;u<e.length&&t<l.tm.concurrency;){n&&n.debug(`Writing points start ${r}: ${u}/${e.length}`);let i=1,o=e[u]?e[u].length:0;for(;u+i<e.length&&o+(e[u+i]?e[u+i].length:0)<32768&&i<32768;)o+=e[u+i]?e[u+i].length:0,i++;const s=e.slice(u,u+i),l=u;c.push(Q(a,s,n,r).then((t=>(n&&n.debug(`Writing points end ${r}: ${l}/${e.length}`),t)))),u+=i,t++}const i=await Promise.all(c);for(let a=0;a<i.length;a++){await g.write(i[a][0]);const t=await s.batchLEMtoU(i[a][0]);o.update(t)}c=[]}await i.endWriteSection(g)}async function Q(t,a,e,n){const i=l[t],o=2*i.F.n8,s=3*i.F.n8,c=2*i.F.n8;let u,d,w,f;if("G1"==t)u="g1m_timesScalarAffine",d="g1m_multiexpAffine",w="g1m_batchToAffine",f="g1m_zero";else{if("G2"!=t)throw new Error("Invalid group");u="g2m_timesScalarAffine",d="g2m_multiexpAffine",w="g2m_batchToAffine",f="g2m_zero"}let p,g,m=0;for(let r=0;r<a.length;r++)m+=a[r]?a[r].length:0;m>32768?(p=new r.BigBuffer(m*o),g=new r.BigBuffer(m*l.Fr.n8)):(p=new Uint8Array(m*o),g=new Uint8Array(m*l.Fr.n8));let h=0,b=0;const y=[j,H,V,N],G=new Uint8Array(l.Fr.n8);l.Fr.toRprLE(G,0,l.Fr.e(1));let S=0;for(let r=0;r<a.length;r++)if(a[r])for(let t=0;t<a[r].length;t++)e&&t&&t%1e4==0&&e.debug(`Configuring big array ${n}: ${t}/${a[r].length}`),p.set(y[a[r][t][0]].slice(a[r][t][1],a[r][t][1]+o),S*o),a[r][t][2]>=0?g.set($.slice(a[r][t][2],a[r][t][2]+l.Fr.n8),S*l.Fr.n8):g.set(G,S*l.Fr.n8),S++;if(a.length>1){const t=[];t.push({cmd:"ALLOCSET",var:0,buff:p}),t.push({cmd:"ALLOCSET",var:1,buff:g}),t.push({cmd:"ALLOC",var:2,len:a.length*s}),h=0,b=0;let e=0;for(let n=0;n<a.length;n++)a[n]?(1==a[n].length?t.push({cmd:"CALL",fnName:u,params:[{var:0,offset:h},{var:1,offset:b},{val:l.Fr.n8},{var:2,offset:e}]}):t.push({cmd:"CALL",fnName:d,params:[{var:0,offset:h},{var:1,offset:b},{val:l.Fr.n8},{val:a[n].length},{var:2,offset:e}]}),h+=o*a[n].length,b+=l.Fr.n8*a[n].length,e+=s):(t.push({cmd:"CALL",fnName:f,params:[{var:2,offset:e}]}),e+=s);t.push({cmd:"CALL",fnName:w,params:[{var:2},{val:a.length},{var:2}]}),t.push({cmd:"GET",out:0,var:2,len:a.length*c});return await l.tm.queueAction(t)}{let t=await i.multiExpAffine(p,g,e,n);return t=[i.toAffine(t)],t}}async function Z(t,a){const e=await s.read(a*h,c[2][0].p+(t+S)*h),n=await s.read(a*h,c[2][0].p+t*h),i=l.tm.concurrency,r=Math.floor(a/i),u=[];for(let o=0;o<i;o++){let t;if(t=o<i-1?r:a-o*r,0==t)continue;const s=e.slice(o*r*h,(o*r+t)*h),c=n.slice(o*r*h,(o*r+t)*h);u.push(J(s,c))}const d=await Promise.all(u);for(let s=0;s<d.length;s++)o.update(d[s][0])}async function J(t,a){const e=t.byteLength/h,n=3*l.G1.F.n8,i=[];i.push({cmd:"ALLOCSET",var:0,buff:t}),i.push({cmd:"ALLOCSET",var:1,buff:a}),i.push({cmd:"ALLOC",var:2,len:e*n});for(let r=0;r<e;r++)i.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:r*h},{var:1,offset:r*h},{var:2,offset:r*n}]});i.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:e},{var:2}]}),i.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:e},{var:2}]}),i.push({cmd:"GET",out:0,var:2,len:e*h});return await l.tm.queueAction(i)}function X(t){const a=new Uint8Array(4);new DataView(a.buffer,a.byteOffset,a.byteLength).setUint32(0,t,!1),o.update(a)}}const kt=U;async function Tt(t,a,e,n){let i;await m.default.ready();const{fd:o,sections:s}=await g.readBinFile(e,"zkey",2),c=await M(o,s,!1);if("groth16"!=c.protocol)throw new Error("zkey file is not groth16");const l=await v(c.q),u=2*l.G1.F.n8,d=await q(o,l,s),w=m.default(64);w.update(d.csHash);let f=l.G1.g;for(let r=0;r<d.contributions.length;r++){const t=d.contributions[r],a=A(w);if(H(a,l,t.delta.g1_s),H(a,l,t.delta.g1_sx),!x(a.digest(),t.transcript))return console.log(`INVALID(${r}): Inconsistent transcript `),!1;const e=et(l,t.transcript);if(i=await kt(l,t.delta.g1_s,t.delta.g1_sx,e,t.delta.g2_spx),!0!==i)return console.log(`INVALID(${r}): public key G1 and G2 do not have the same ration `),!1;if(i=await kt(l,f,t.deltaAfter,e,t.delta.g2_spx),!0!==i)return console.log(`INVALID(${r}): deltaAfter does not fillow the public key `),!1;if(1==t.type){const a=z(t.beaconHash,t.numIterationsExp),e=l.Fr.fromRng(a),n=l.G1.toAffine(l.G1.fromRng(a)),i=l.G1.toAffine(l.G1.timesFr(n,e));if(!0!==l.G1.eq(n,t.delta.g1_s))return console.log(`INVALID(${r}): Key of the beacon does not match. g1_s `),!1;if(!0!==l.G1.eq(i,t.delta.g1_sx))return console.log(`INVALID(${r}): Key of the beacon does not match. g1_sx `),!1}V(w,l,t);const n=m.default(64);V(n,l,t),t.contributionHash=n.digest(),f=t.deltaAfter}const{fd:p,sections:b}=await g.readBinFile(t,"zkey",2),y=await M(p,b,!1);if("groth16"!=y.protocol)throw new Error("zkeyinit file is not groth16");if(!r.Scalar.eq(y.q,c.q)||!r.Scalar.eq(y.r,c.r)||y.n8q!=c.n8q||y.n8r!=c.n8r)return n&&n.error("INVALID:  Different curves"),!1;if(y.nVars!=c.nVars||y.nPublic!=c.nPublic||y.domainSize!=c.domainSize)return n&&n.error("INVALID:  Different circuit parameters"),!1;if(!l.G1.eq(c.vk_alpha_1,y.vk_alpha_1))return n&&n.error("INVALID:  Invalid alpha1"),!1;if(!l.G1.eq(c.vk_beta_1,y.vk_beta_1))return n&&n.error("INVALID:  Invalid beta1"),!1;if(!l.G2.eq(c.vk_beta_2,y.vk_beta_2))return n&&n.error("INVALID:  Invalid beta2"),!1;if(!l.G2.eq(c.vk_gamma_2,y.vk_gamma_2))return n&&n.error("INVALID:  Invalid gamma2"),!1;if(!l.G1.eq(c.vk_delta_1,f))return n&&n.error("INVALID:  Invalid delta1"),!1;if(i=await kt(l,l.G1.g,f,l.G2.g,c.vk_delta_2),!0!==i)return n&&n.error("INVALID:  Invalid delta2"),!1;const G=await q(p,l,b);if(!x(d.csHash,G.csHash))return n&&n.error("INVALID:  Circuit does not match"),!1;if(s[8][0].size!=u*(c.nVars-c.nPublic-1))return n&&n.error("INVALID:  Invalid L section size"),!1;if(s[9][0].size!=u*c.domainSize)return n&&n.error("INVALID:  Invalid H section size"),!1;let S;if(S=await g.sectionIsEqual(o,s,p,b,3),!S)return n&&n.error("INVALID:  IC section is not identical"),!1;if(S=await g.sectionIsEqual(o,s,p,b,4),!S)return n&&n.error("Coeffs section is not identical"),!1;if(S=await g.sectionIsEqual(o,s,p,b,5),!S)return n&&n.error("A section is not identical"),!1;if(S=await g.sectionIsEqual(o,s,p,b,6),!S)return n&&n.error("B1 section is not identical"),!1;if(S=await g.sectionIsEqual(o,s,p,b,7),!S)return n&&n.error("B2 section is not identical"),!1;if(i=await async function(t,a,e,r,o,s,c,u,d){const w=1<<20,f=l[t],p=2*f.F.n8;await g.startReadUniqueSection(a,e,s),await g.startReadUniqueSection(r,o,s);let m=f.zero,b=f.zero;const y=e[s][0].size/p;for(let i=0;i<y;i+=w){n&&n.debug(`Same ratio check ${d}:  ${i}/${y}`);const t=Math.min(y-i,w),e=await a.read(t*p),o=await r.read(t*p),s=new Uint8Array(4*t);h.default.randomFillSync(s);const c=await f.multiExpAffine(e,s),l=await f.multiExpAffine(o,s);m=f.add(m,c),b=f.add(b,l)}return await g.endReadSection(a),await g.endReadSection(r),0==y||(i=await kt(l,m,b,c,u),!0===i)}("G1",p,b,o,s,8,c.vk_delta_2,y.vk_delta_2,"L section"),!0!==i)return n&&n.error("L section does not match"),!1;if(i=await async function(){const t=1<<20,e=l.G1,u=l.Fr,d=2*e.F.n8,{fd:w,sections:f}=await g.readBinFile(a,"ptau",1);let p=new r.BigBuffer(c.domainSize*c.n8r);const m=new Array(8);for(let a=0;a<8;a++)m[a]=h.default.randomBytes(4).readUInt32BE(0,!0);const b=new r.ChaCha(m);for(let a=0;a<c.domainSize-1;a++){const t=u.fromRng(b);u.toRprLE(p,a*c.n8r,t)}u.toRprLE(p,(c.domainSize-1)*c.n8r,u.zero);let G,S=e.zero;for(let a=0;a<c.domainSize;a+=t){n&&n.debug(`H Verificaition(tau):  ${a}/${c.domainSize}`);const i=Math.min(c.domainSize-a,t),r=await w.read(d*i,f[2][0].p+c.domainSize*d+a*d),o=await w.read(d*i,f[2][0].p+a*d),s=await _(r,o),l=p.slice(a*c.n8r,(a+i)*c.n8r),u=await e.multiExpAffine(s,l);S=e.add(S,u)}if(p=await u.batchToMontgomery(p),c.power<u.s)G=u.neg(u.e(2));else{const t=2**u.s,a=u.exp(u.shift,t);G=u.sub(a,u.one)}const v=c.power<u.s?u.w[c.power+1]:u.shift;p=await u.batchApplyKey(p,G,v),p=await u.fft(p),p=await u.batchFromMontgomery(p),await g.startReadUniqueSection(o,s,9);let F=e.zero;for(let a=0;a<c.domainSize;a+=t){n&&n.debug(`H Verificaition(lagrange):  ${a}/${c.domainSize}`);const i=Math.min(c.domainSize-a,t),r=await o.read(d*i),s=p.slice(a*c.n8r,(a+i)*c.n8r),l=await e.multiExpAffine(r,s);F=e.add(F,l)}return await g.endReadSection(o),i=await kt(l,S,F,c.vk_delta_2,y.vk_delta_2),!0===i}(),!0!==i)return n&&n.error("H section does not match"),!1;n&&n.info(B(d.csHash,"Circuit Hash: ")),await o.close(),await p.close();for(let r=d.contributions.length-1;r>=0;r--){const t=d.contributions[r];n&&n.info("-------------------------"),n&&n.info(B(t.contributionHash,`contribution #${r+1} ${t.name?t.name:""}:`)),1==t.type&&(n&&n.info(`Beacon generator: ${k(t.beaconHash)}`),n&&n.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}return n&&n.info("-------------------------"),n&&n.info("ZKey Ok!"),!0;async function _(t,a){const e=2*l.G1.F.n8,n=t.byteLength/e,i=l.tm.concurrency,r=Math.floor(n/i),o=[];for(let l=0;l<i;l++){let e;if(e=l<i-1?r:n-l*r,0==e)continue;const s=t.slice(l*r*u,(l*r+e)*u),c=a.slice(l*r*u,(l*r+e)*u);o.push(F(s,c))}const s=await Promise.all(o),c=new Uint8Array(n*e);let d=0;for(let l=0;l<s.length;l++)c.set(s[l][0],d),d+=s[l][0].byteLength;return c}async function F(t,a){const e=2*l.G1.F.n8,n=3*l.G1.F.n8,i=t.byteLength/e,r=[];r.push({cmd:"ALLOCSET",var:0,buff:t}),r.push({cmd:"ALLOCSET",var:1,buff:a}),r.push({cmd:"ALLOC",var:2,len:i*n});for(let o=0;o<i;o++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:o*e},{var:1,offset:o*e},{var:2,offset:o*n}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:i},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:i*e});return await l.tm.queueAction(r)}}const{stringifyBigInts:Ct}=r.utils;async function It(t){const{fd:a,sections:e}=await g.readBinFile(t,"zkey",2),n=await M(a,e);let i;if("groth16"==n.protocol)i=await async function(t,a,e){const n=await v(t.q),i=2*n.G1.F.n8,r=await n.pairing(t.vk_alpha_1,t.vk_beta_2);let o={protocol:t.protocol,curve:n.name,nPublic:t.nPublic,vk_alpha_1:n.G1.toObject(t.vk_alpha_1),vk_beta_2:n.G2.toObject(t.vk_beta_2),vk_gamma_2:n.G2.toObject(t.vk_gamma_2),vk_delta_2:n.G2.toObject(t.vk_delta_2),vk_alphabeta_12:n.Gt.toObject(r)};await g.startReadUniqueSection(a,e,3),o.IC=[];for(let s=0;s<=t.nPublic;s++){const t=await a.read(i),e=n.G1.toObject(t);o.IC.push(e)}return await g.endReadSection(a),o=Ct(o),o}(n,a,e);else{if("plonk"!=n.protocol)throw new Error("zkey file is not groth16");i=await async function(t){const a=await v(t.q);let e={protocol:t.protocol,curve:a.name,nPublic:t.nPublic,power:t.power,k1:a.Fr.toObject(t.k1),k2:a.Fr.toObject(t.k2),Qm:a.G1.toObject(t.Qm),Ql:a.G1.toObject(t.Ql),Qr:a.G1.toObject(t.Qr),Qo:a.G1.toObject(t.Qo),Qc:a.G1.toObject(t.Qc),S1:a.G1.toObject(t.S1),S2:a.G1.toObject(t.S2),S3:a.G1.toObject(t.S3),X_2:a.G2.toObject(t.X_2),w:a.Fr.toObject(a.Fr.w[t.power])};return e=Ct(e),e}(n)}return await a.close(),i}var $t=Object.freeze({__proto__:null,newZKey:Rt,exportBellman:async function(t,a,e){const{fd:n,sections:i}=await g.readBinFile(t,"zkey",2),r=await M(n,i);if("groth16"!=r.protocol)throw new Error("zkey file is not groth16");const o=await v(r.q),s=2*o.G1.F.n8,c=2*o.G2.F.n8,l=await q(n,o,i),u=await b.createOverride(a);let d;await G(r.vk_alpha_1),await G(r.vk_beta_1),await S(r.vk_beta_2),await S(r.vk_gamma_2),await G(r.vk_delta_1),await S(r.vk_delta_2),d=await g.readSection(n,i,3),d=await o.G1.batchLEMtoU(d),await _("G1",d);const w=await g.readSection(n,i,9);let f,p,m,h,y;f=await o.G1.fft(w,"affine","jacobian",e),f=await o.G1.batchApplyKey(f,o.Fr.neg(o.Fr.e(2)),o.Fr.w[r.power+1],"jacobian","affine",e),f=f.slice(0,f.byteLength-s),f=await o.G1.batchLEMtoU(f),await _("G1",f),p=await g.readSection(n,i,8),p=await o.G1.batchLEMtoU(p),await _("G1",p),m=await g.readSection(n,i,5),m=await o.G1.batchLEMtoU(m),await _("G1",m),h=await g.readSection(n,i,6),h=await o.G1.batchLEMtoU(h),await _("G1",h),y=await g.readSection(n,i,7),y=await o.G2.batchLEMtoU(y),await _("G2",y),await u.write(l.csHash),await async function(t){const a=new Uint8Array(4);new DataView(a.buffer,a.byteOffset,a.byteLength).setUint32(0,t,!1),await u.write(a)}(l.contributions.length);for(let g=0;g<l.contributions.length;g++){const t=l.contributions[g];await G(t.deltaAfter),await G(t.delta.g1_s),await G(t.delta.g1_sx),await S(t.delta.g2_spx),await u.write(t.transcript)}async function G(t){const a=new Uint8Array(s);o.G1.toRprUncompressed(a,0,t),await u.write(a)}async function S(t){const a=new Uint8Array(c);o.G2.toRprUncompressed(a,0,t),await u.write(a)}async function _(t,a){let e;e="G1"==t?s:c;const n=new Uint8Array(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,a.byteLength/e,!1),await u.write(n),await u.write(a)}await n.close(),await u.close()},importBellman:async function(t,a,e,n,i){const{fd:r,sections:o}=await g.readBinFile(t,"zkey",2),s=await M(r,o,!1);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const c=await v(s.q),l=2*c.G1.F.n8,u=2*c.G2.F.n8,d=await q(r,c,o),w={},f=await b.readExisting(a);f.pos=3*l+3*u+8+l*s.nVars+4+l*(s.domainSize-1)+4+l*s.nVars+4+l*s.nVars+4+u*s.nVars,w.csHash=await f.read(64);const p=await f.readUBE32();w.contributions=[];for(let g=0;g<p;g++){const t={delta:{}};t.deltaAfter=await E(f),t.delta.g1_s=await E(f),t.delta.g1_sx=await E(f),t.delta.g2_spx=await B(f),t.transcript=await f.read(64),g<d.contributions.length&&(t.type=d.contributions[g].type,1==t.type&&(t.beaconHash=d.contributions[g].beaconHash,t.numIterationsExp=d.contributions[g].numIterationsExp),d.contributions[g].name&&(t.name=d.contributions[g].name)),w.contributions.push(t)}if(!x(w.csHash,d.csHash))return i&&i.error("Hash of the original circuit does not match with the MPC one"),!1;if(d.contributions.length>w.contributions.length)return i&&i.error("The impoerted file does not include new contributions"),!1;for(let g=0;g<d.contributions.length;g++)if(!A(d.contributions[g],w.contributions[g]))return i&&i.error(`Previos contribution ${g} does not match`),!1;if(n)for(let g=d.contributions.length;g<w.contributions.length;g++)w.contributions[g].name=n;const m=await g.createBinFile(e,"zkey",1,10);if(f.pos=0,f.pos+=l,f.pos+=l,f.pos+=u,f.pos+=u,s.vk_delta_1=await E(f),s.vk_delta_2=await B(f),await T(m,s),await f.readUBE32()!=s.nPublic+1)return i&&i.error("Invalid number of points in IC"),await m.discard(),!1;if(f.pos+=l*(s.nPublic+1),await g.copySection(r,o,m,3),await g.copySection(r,o,m,4),await f.readUBE32()!=s.domainSize-1)return i&&i.error("Invalid number of points in H"),await m.discard(),!1;let h;const y=await f.read(l*(s.domainSize-1)),G=await c.G1.batchUtoLEM(y);h=new Uint8Array(s.domainSize*l),h.set(G),c.G1.toRprLEM(h,l*(s.domainSize-1),c.G1.zeroAffine);const S=c.Fr.neg(c.Fr.inv(c.Fr.e(2))),_=c.Fr.inv(c.Fr.w[s.power+1]);if(h=await c.G1.batchApplyKey(h,S,_,"affine","jacobian",i),h=await c.G1.ifft(h,"jacobian","affine",i),await g.startWriteSection(m,9),await m.write(h),await g.endWriteSection(m),await f.readUBE32()!=s.nVars-s.nPublic-1)return i&&i.error("Invalid number of points in L"),await m.discard(),!1;let F;return F=await f.read(l*(s.nVars-s.nPublic-1)),F=await c.G1.batchUtoLEM(F),await g.startWriteSection(m,8),await m.write(F),await g.endWriteSection(m),await f.readUBE32()!=s.nVars?(i&&i.error("Invalid number of points in A"),await m.discard(),!1):(f.pos+=l*s.nVars,await g.copySection(r,o,m,5),await f.readUBE32()!=s.nVars?(i&&i.error("Invalid number of points in B1"),await m.discard(),!1):(f.pos+=l*s.nVars,await g.copySection(r,o,m,6),await f.readUBE32()!=s.nVars?(i&&i.error("Invalid number of points in B2"),await m.discard(),!1):(f.pos+=u*s.nVars,await g.copySection(r,o,m,7),await j(m,c,w),await f.close(),await m.close(),await r.close(),!0)));async function E(t){const a=await t.read(2*c.G1.F.n8);return c.G1.fromRprUncompressed(a,0)}async function B(t){const a=await t.read(2*c.G2.F.n8);return c.G2.fromRprUncompressed(a,0)}function A(t,a){return!!c.G1.eq(t.deltaAfter,a.deltaAfter)&&(!!c.G1.eq(t.delta.g1_s,a.delta.g1_s)&&(!!c.G1.eq(t.delta.g1_sx,a.delta.g1_sx)&&(!!c.G2.eq(t.delta.g2_spx,a.delta.g2_spx)&&!!x(t.transcript,a.transcript))))}},verifyFromR1cs:async function(t,a,e,n){const i={type:"bigMem"};return await Rt(t,a,i,n),await Tt(i,a,e,n)},verifyFromInit:Tt,contribute:async function(t,a,e,n,i){await m.default.ready();const{fd:r,sections:o}=await g.readBinFile(t,"zkey",2),s=await M(r,o);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const c=await v(s.q),l=await q(r,c,o),u=await g.createBinFile(a,"zkey",1,10),d=await L(n),w=m.default(64);w.update(l.csHash);for(let g=0;g<l.contributions.length;g++)V(w,c,l.contributions[g]);const f={delta:{}};f.delta.prvKey=c.Fr.fromRng(d),f.delta.g1_s=c.G1.toAffine(c.G1.fromRng(d)),f.delta.g1_sx=c.G1.toAffine(c.G1.timesFr(f.delta.g1_s,f.delta.prvKey)),H(w,c,f.delta.g1_s),H(w,c,f.delta.g1_sx),f.transcript=w.digest(),f.delta.g2_sp=et(c,f.transcript),f.delta.g2_spx=c.G2.toAffine(c.G2.timesFr(f.delta.g2_sp,f.delta.prvKey)),s.vk_delta_1=c.G1.timesFr(s.vk_delta_1,f.delta.prvKey),s.vk_delta_2=c.G2.timesFr(s.vk_delta_2,f.delta.prvKey),f.deltaAfter=s.vk_delta_1,f.type=0,e&&(f.name=e),l.contributions.push(f),await T(u,s),await g.copySection(r,o,u,3),await g.copySection(r,o,u,4),await g.copySection(r,o,u,5),await g.copySection(r,o,u,6),await g.copySection(r,o,u,7);const p=c.Fr.inv(f.delta.prvKey);await bt(r,o,u,8,c,"G1",p,c.Fr.e(1),"L Section",i),await bt(r,o,u,9,c,"G1",p,c.Fr.e(1),"H Section",i),await j(u,c,l),await r.close(),await u.close();const h=m.default(64);V(h,c,f);const b=h.digest();return i&&i.info(B(l.csHash,"Circuit Hash: ")),i&&i.info(B(b,"Contribution Hash: ")),b},beacon:async function(t,a,e,n,i,r){await m.default.ready();const o=R(n);if(0==o.byteLength||2*o.byteLength!=n.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((i=parseInt(i))<10||i>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:s,sections:c}=await g.readBinFile(t,"zkey",2),l=await M(s,c);if("groth16"!=l.protocol)throw new Error("zkey file is not groth16");const u=await v(l.q),d=await q(s,u,c),w=await g.createBinFile(a,"zkey",1,10),f=await z(o,i),p=m.default(64);p.update(d.csHash);for(let g=0;g<d.contributions.length;g++)V(p,u,d.contributions[g]);const h={delta:{}};h.delta.prvKey=u.Fr.fromRng(f),h.delta.g1_s=u.G1.toAffine(u.G1.fromRng(f)),h.delta.g1_sx=u.G1.toAffine(u.G1.timesFr(h.delta.g1_s,h.delta.prvKey)),H(p,u,h.delta.g1_s),H(p,u,h.delta.g1_sx),h.transcript=p.digest(),h.delta.g2_sp=et(u,h.transcript),h.delta.g2_spx=u.G2.toAffine(u.G2.timesFr(h.delta.g2_sp,h.delta.prvKey)),l.vk_delta_1=u.G1.timesFr(l.vk_delta_1,h.delta.prvKey),l.vk_delta_2=u.G2.timesFr(l.vk_delta_2,h.delta.prvKey),h.deltaAfter=l.vk_delta_1,h.type=1,h.numIterationsExp=i,h.beaconHash=o,e&&(h.name=e),d.contributions.push(h),await T(w,l),await g.copySection(s,c,w,3),await g.copySection(s,c,w,4),await g.copySection(s,c,w,5),await g.copySection(s,c,w,6),await g.copySection(s,c,w,7);const b=u.Fr.inv(h.delta.prvKey);await bt(s,c,w,8,u,"G1",b,u.Fr.e(1),"L Section",r),await bt(s,c,w,9,u,"G1",b,u.Fr.e(1),"H Section",r),await j(w,u,d),await s.close(),await w.close();const y=m.default(64);V(y,u,h);const G=y.digest();return r&&r.info(B(G,"Contribution Hash: ")),G},exportJson:async function(t){const a=await async function(t,a){const{fd:e,sections:n}=await g.readBinFile(t,"zkey",1),i=await M(e,n,"groth16"),o=new r.F1Field(i.r),s=r.Scalar.mod(r.Scalar.shl(1,8*i.n8r),i.r),c=o.inv(s),l=o.mul(c,c);let u=await v(i.q);await g.startReadUniqueSection(e,n,3),i.IC=[];for(let r=0;r<=i.nPublic;r++){const t=await $(e,u,a);i.IC.push(t)}await g.endReadSection(e),await g.startReadUniqueSection(e,n,4);const d=await e.readULE32();i.ccoefs=[];for(let r=0;r<d;r++){const t=await e.readULE32(),a=await e.readULE32(),n=await e.readULE32(),r=await w();i.ccoefs.push({matrix:t,constraint:a,signal:n,value:r})}await g.endReadSection(e),await g.startReadUniqueSection(e,n,5),i.A=[];for(let r=0;r<i.nVars;r++){const t=await $(e,u,a);i.A[r]=t}await g.endReadSection(e),await g.startReadUniqueSection(e,n,6),i.B1=[];for(let r=0;r<i.nVars;r++){const t=await $(e,u,a);i.B1[r]=t}await g.endReadSection(e),await g.startReadUniqueSection(e,n,7),i.B2=[];for(let r=0;r<i.nVars;r++){const t=await O(e,u,a);i.B2[r]=t}await g.endReadSection(e),await g.startReadUniqueSection(e,n,8),i.C=[];for(let r=i.nPublic+1;r<i.nVars;r++){const t=await $(e,u,a);i.C[r]=t}await g.endReadSection(e),await g.startReadUniqueSection(e,n,9),i.hExps=[];for(let r=0;r<i.domainSize;r++){const t=await $(e,u,a);i.hExps.push(t)}return await g.endReadSection(e),await e.close(),i;async function w(){const t=await g.readBigInt(e,i.n8r);return o.mul(t,l)}}(t,!0);return a},bellmanContribute:async function(t,a,e,n,i){await m.default.ready();const r=await L(n),o=t.Fr.fromRng(r),s=t.Fr.inv(o),c=2*t.G1.F.n8,l=2*t.G2.F.n8,u=await b.readExisting(a),d=await b.createOverride(e);await R(c),await R(c),await R(l),await R(l);const w=await k(),f=t.G1.timesFr(w,o);await C(f);const p=await T(),g=t.G2.timesFr(p,o);await I(g);const h=await u.readUBE32();await d.writeUBE32(h),await R(h*c);const y=await u.readUBE32();await d.writeUBE32(y),await yt(u,d,null,t,"G1",y,s,t.Fr.e(1),"UNCOMPRESSED","H",i);const G=await u.readUBE32();await d.writeUBE32(G),await yt(u,d,null,t,"G1",G,s,t.Fr.e(1),"UNCOMPRESSED","L",i);const S=await u.readUBE32();await d.writeUBE32(S),await R(S*c);const _=await u.readUBE32();await d.writeUBE32(_),await R(_*c);const v=await u.readUBE32();await d.writeUBE32(v),await R(v*l);const F=m.default(64),E={};E.csHash=await u.read(64),F.update(E.csHash);const x=await u.readUBE32();E.contributions=[];for(let m=0;m<x;m++){const a={delta:{}};a.deltaAfter=await k(),a.delta.g1_s=await k(),a.delta.g1_sx=await k(),a.delta.g2_spx=await T(),a.transcript=await u.read(64),E.contributions.push(a),V(F,t,a)}const A={delta:{}};A.delta.prvKey=o,A.delta.g1_s=t.G1.toAffine(t.G1.fromRng(r)),A.delta.g1_sx=t.G1.toAffine(t.G1.timesFr(A.delta.g1_s,o)),H(F,t,A.delta.g1_s),H(F,t,A.delta.g1_sx),A.transcript=F.digest(),A.delta.g2_sp=et(t,A.transcript),A.delta.g2_spx=t.G2.toAffine(t.G2.timesFr(A.delta.g2_sp,o)),A.deltaAfter=f,A.type=0,E.contributions.push(A),await d.write(E.csHash),await d.writeUBE32(E.contributions.length);for(let m=0;m<E.contributions.length;m++){const t=E.contributions[m];await C(t.deltaAfter),await C(t.delta.g1_s),await C(t.delta.g1_sx),await I(t.delta.g2_spx),await d.write(t.transcript)}const U=m.default(64);V(U,t,A);const z=U.digest();return i&&i.info(B(z,"Contribution Hash: ")),await d.close(),await u.close(),z;async function R(t){const a=2*u.pageSize;for(let e=0;e<t;e+=a){const n=Math.min(t-e,a),i=await u.read(n);await d.write(i)}}async function k(){const a=await u.read(2*t.G1.F.n8);return t.G1.fromRprUncompressed(a,0)}async function T(){const a=await u.read(2*t.G2.F.n8);return t.G2.fromRprUncompressed(a,0)}async function C(a){const e=new Uint8Array(c);t.G1.toRprUncompressed(e,0,a),await d.write(e)}async function I(a){const e=new Uint8Array(l);t.G2.toRprUncompressed(e,0,a),await d.write(e)}},exportVerificationKey:It,exportSolidityVerifier:async function(t,a,e){const n=await It(t);let i=a[n.protocol];return y.default.render(i,n)}});const{stringifyBigInts:Ot}=r.utils,{keccak256:Mt}=G.default;async function Pt(t,a,e){const{fd:n,sections:i}=await g.readBinFile(a,"wtns",2,1<<25,1<<23),o=await N(n,i),{fd:s,sections:c}=await g.readBinFile(t,"zkey",2,1<<25,1<<23),l=await M(s,c);if("plonk"!=l.protocol)throw new Error("zkey file is not plonk");if(!r.Scalar.eq(l.r,o.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=l.nVars-l.nAdditions)throw new Error(`Invalid witness length. Circuit: ${l.nVars}, witness: ${o.nWitness}, ${l.nAdditions}`);const u=l.curve,d=u.Fr,w=u.G1,f=u.Fr.n8;e&&e.debug("Reading Wtns");const p=await g.readSection(n,i,2);p.set(d.zero,0);const m=new r.BigBuffer(f*l.nAdditions);let h,b,y,G,S,_,v,F,E,B,x,A,U,L;await async function(){const t=await g.readSection(s,c,3),a=8+2*u.Fr.n8;for(let e=0;e<l.nAdditions;e++){const n=P(t,e*a),i=P(t,e*a+4),r=t.slice(e*a+8,e*a+8+f),o=t.slice(e*a+8+f,e*a+8+2*f),s=q(n),c=q(i),l=u.Fr.add(u.Fr.mul(r,s),u.Fr.mul(o,c));m.set(l,f*e)}}();let z={};const R=new r.BigBuffer(l.domainSize*f*4*3);let k=c[12][0].p+l.domainSize*f;await s.readToBuffer(R,0,l.domainSize*f*4,k),k+=l.domainSize*f*5,await s.readToBuffer(R,l.domainSize*f*4,l.domainSize*f*4,k),k+=l.domainSize*f*5,await s.readToBuffer(R,l.domainSize*f*8,l.domainSize*f*4,k);const T=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(T,0,l.domainSize*f,c[12][0].p);const C=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(C,0,l.domainSize*f,c[12][0].p+5*l.domainSize*f);const I=await g.readSection(s,c,14),$={};await async function(){$.b=[];for(let t=1;t<=9;t++)$.b[t]=u.Fr.random();[h,b,y]=await async function(){let t=new r.BigBuffer(l.domainSize*f),a=new r.BigBuffer(l.domainSize*f),e=new r.BigBuffer(l.domainSize*f);const n=await g.readSection(s,c,4),i=await g.readSection(s,c,5),o=await g.readSection(s,c,6);for(let r=0;r<l.nConstrains;r++){const s=P(n,4*r);t.set(q(s),r*f);const c=P(i,4*r);a.set(q(c),r*f);const l=P(o,4*r);e.set(q(l),r*f)}return t=await d.batchToMontgomery(t),a=await d.batchToMontgomery(a),e=await d.batchToMontgomery(e),[t,a,e]}(),[E,S]=await K(h,[$.b[2],$.b[1]]),[B,_]=await K(b,[$.b[4],$.b[3]]),[x,v]=await K(y,[$.b[6],$.b[5]]),z.A=await V(E,"multiexp A"),z.B=await V(B,"multiexp B"),z.C=await V(x,"multiexp C")}(),await async function(){const t=new Uint8Array(l.nPublic*f+2*w.F.n8*3);for(let e=0;e<l.nPublic;e++)d.toRprBE(t,e*f,h.slice(e*f,(e+1)*f));w.toRprUncompressed(t,l.nPublic*f+0,z.A),w.toRprUncompressed(t,l.nPublic*f+2*w.F.n8,z.B),w.toRprUncompressed(t,l.nPublic*f+4*w.F.n8,z.C),$.beta=W(t),e&&e.debug("beta: "+d.toString($.beta));const a=new Uint8Array(f);d.toRprBE(a,0,$.beta),$.gamma=W(a),e&&e.debug("gamma: "+d.toString($.gamma));let n=new r.BigBuffer(d.n8*l.domainSize),i=new r.BigBuffer(d.n8*l.domainSize);n.set(d.one,0),i.set(d.one,0);let o=d.one;for(let e=0;e<l.domainSize;e++){let t=h.slice(e*f,(e+1)*f);t=d.add(t,d.mul($.beta,o)),t=d.add(t,$.gamma);let a=b.slice(e*f,(e+1)*f);a=d.add(a,d.mul(l.k1,d.mul($.beta,o))),a=d.add(a,$.gamma);let r=y.slice(e*f,(e+1)*f);r=d.add(r,d.mul(l.k2,d.mul($.beta,o))),r=d.add(r,$.gamma);const s=d.mul(t,d.mul(a,r));let c=h.slice(e*f,(e+1)*f);c=d.add(c,d.mul(R.slice(e*f*4,e*f*4+f),$.beta)),c=d.add(c,$.gamma);let u=b.slice(e*f,(e+1)*f);u=d.add(u,d.mul(R.slice(4*(l.domainSize+e)*f,4*(l.domainSize+e)*f+f),$.beta)),u=d.add(u,$.gamma);let w=y.slice(e*f,(e+1)*f);w=d.add(w,d.mul(R.slice(4*(2*l.domainSize+e)*f,4*(2*l.domainSize+e)*f+f),$.beta)),w=d.add(w,$.gamma);const p=d.mul(c,d.mul(u,w));n.set(d.mul(n.slice(e*f,(e+1)*f),s),(e+1)%l.domainSize*f),i.set(d.mul(i.slice(e*f,(e+1)*f),p),(e+1)%l.domainSize*f),o=d.mul(o,d.w[l.power])}i=await d.batchInverse(i);for(let e=0;e<l.domainSize;e++)n.set(d.mul(n.slice(e*f,(e+1)*f),i.slice(e*f,(e+1)*f)),e*f);if(!d.eq(n.slice(0,f),d.one))throw new Error("Copy constraints does not match");G=n,[A,F]=await K(G,[$.b[9],$.b[8],$.b[7]]),z.Z=await V(A,"multiexp Z")}(),await async function(){e&&e.debug("phse3: Reading QM4");const t=new r.BigBuffer(4*l.domainSize*f);await s.readToBuffer(t,0,l.domainSize*f*4,c[7][0].p+l.domainSize*f),e&&e.debug("phse3: Reading QL4");const a=new r.BigBuffer(4*l.domainSize*f);await s.readToBuffer(a,0,l.domainSize*f*4,c[8][0].p+l.domainSize*f),e&&e.debug("phse3: Reading QR4");const n=new r.BigBuffer(4*l.domainSize*f);await s.readToBuffer(n,0,l.domainSize*f*4,c[9][0].p+l.domainSize*f),e&&e.debug("phse3: Reading QO4");const i=new r.BigBuffer(4*l.domainSize*f);await s.readToBuffer(i,0,l.domainSize*f*4,c[10][0].p+l.domainSize*f),e&&e.debug("phse3: Reading QC4");const o=new r.BigBuffer(4*l.domainSize*f);await s.readToBuffer(o,0,l.domainSize*f*4,c[11][0].p+l.domainSize*f);const u=await g.readSection(s,c,13),p=new Uint8Array(2*w.F.n8);w.toRprUncompressed(p,0,z.Z),$.alpha=W(p),e&&e.debug("alpha: "+d.toString($.alpha));const m=[d.zero,d.add(d.e(-1),d.w[2]),d.e(-2),d.sub(d.e(-1),d.w[2])],b=[d.zero,d.add(d.zero,d.mul(d.e(-2),d.w[2])),d.e(4),d.sub(d.zero,d.mul(d.e(-2),d.w[2]))],y=[d.zero,d.add(d.e(2),d.mul(d.e(2),d.w[2])),d.e(-8),d.sub(d.e(2),d.mul(d.e(2),d.w[2]))],G=new r.BigBuffer(4*l.domainSize*f),E=new r.BigBuffer(4*l.domainSize*f);let B=d.one;for(let r=0;r<4*l.domainSize;r++){r%4096==0&&e&&e.debug(`calculating t ${r}/${4*l.domainSize}`);const s=S.slice(r*f,r*f+f),c=_.slice(r*f,r*f+f),w=v.slice(r*f,r*f+f),p=F.slice(r*f,r*f+f),g=F.slice((r+4*l.domainSize+4)%(4*l.domainSize)*f,(r+4*l.domainSize+4)%(4*l.domainSize)*f+f),m=t.slice(r*f,r*f+f),b=a.slice(r*f,r*f+f),y=n.slice(r*f,r*f+f),x=i.slice(r*f,r*f+f),A=o.slice(r*f,r*f+f),U=R.slice(r*f,r*f+f),z=R.slice((r+4*l.domainSize)*f,(r+4*l.domainSize)*f+f),T=R.slice((r+8*l.domainSize)*f,(r+8*l.domainSize)*f+f),C=d.add($.b[2],d.mul($.b[1],B)),I=d.add($.b[4],d.mul($.b[3],B)),O=d.add($.b[6],d.mul($.b[5],B)),M=d.square(B),P=d.add(d.add(d.mul($.b[7],M),d.mul($.b[8],B)),$.b[9]),q=d.mul(B,d.w[l.power]),W=d.square(q),j=d.add(d.add(d.mul($.b[7],W),d.mul($.b[8],q)),$.b[9]);let H=d.zero;for(let t=0;t<l.nPublic;t++)H=d.sub(H,d.mul(u.slice((5*t*l.domainSize+l.domainSize+r)*f,(5*t*l.domainSize+l.domainSize+r+1)*f),h.slice(t*f,(t+1)*f)));let[V,N]=L(s,c,C,I,r%4);V=d.mul(V,m),N=d.mul(N,m),V=d.add(V,d.mul(s,b)),N=d.add(N,d.mul(C,b)),V=d.add(V,d.mul(c,y)),N=d.add(N,d.mul(I,y)),V=d.add(V,d.mul(w,x)),N=d.add(N,d.mul(O,x)),V=d.add(V,H),V=d.add(V,A);const K=d.mul($.beta,B);let D=s;D=d.add(D,K),D=d.add(D,$.gamma);let Q=c;Q=d.add(Q,d.mul(K,l.k1)),Q=d.add(Q,$.gamma);let Z=w;Z=d.add(Z,d.mul(K,l.k2)),Z=d.add(Z,$.gamma);let J=p,[X,Y]=k(D,Q,Z,J,C,I,O,P,r%4);X=d.mul(X,$.alpha),Y=d.mul(Y,$.alpha);let tt=s;tt=d.add(tt,d.mul($.beta,U)),tt=d.add(tt,$.gamma);let at=c;at=d.add(at,d.mul($.beta,z)),at=d.add(at,$.gamma);let et=w;et=d.add(et,d.mul($.beta,T)),et=d.add(et,$.gamma);let nt=g,[it,rt]=k(tt,at,et,nt,C,I,O,j,r%4);it=d.mul(it,$.alpha),rt=d.mul(rt,$.alpha);let ot=d.sub(p,d.one);ot=d.mul(ot,u.slice((l.domainSize+r)*f,(l.domainSize+r+1)*f)),ot=d.mul(ot,d.mul($.alpha,$.alpha));let st=d.mul(P,u.slice((l.domainSize+r)*f,(l.domainSize+r+1)*f));st=d.mul(st,d.mul($.alpha,$.alpha));let ct=d.add(d.sub(d.add(V,X),it),ot),lt=d.add(d.sub(d.add(N,Y),rt),st);G.set(ct,r*f),E.set(lt,r*f),B=d.mul(B,d.w[l.power+2])}e&&e.debug("ifft T");let x=await d.ifft(G);e&&e.debug("dividing T/Z");for(let e=0;e<l.domainSize;e++)x.set(d.neg(x.slice(e*f,e*f+f)),e*f);for(let e=l.domainSize;e<4*l.domainSize;e++){const t=d.sub(x.slice((e-l.domainSize)*f,(e-l.domainSize)*f+f),x.slice(e*f,e*f+f));if(x.set(t,e*f),e>3*l.domainSize-4&&!d.isZero(t))throw new Error("T Polynomial is not divisible")}e&&e.debug("ifft Tz");const A=await d.ifft(E);for(let e=0;e<4*l.domainSize;e++){const t=A.slice(e*f,(e+1)*f);if(e>3*l.domainSize+5){if(!d.isZero(t))throw new Error("Tz Polynomial is not well calculated")}else x.set(d.add(x.slice(e*f,(e+1)*f),t),e*f)}function L(t,a,e,n,i){let r,o;const s=d.mul(t,a),c=d.mul(t,n),l=d.mul(e,a);r=s;let u=d.mul(e,n);return o=d.add(c,l),i&&(o=d.add(o,d.mul(m[i],u))),[r,o]}function k(t,a,e,n,i,r,o,s,c){let l,u;const w=d.mul(t,a),f=d.mul(t,r),p=d.mul(i,a),g=d.mul(i,r),h=d.mul(e,n),G=d.mul(e,s),S=d.mul(o,n),_=d.mul(o,s);l=d.mul(w,h);let v=d.mul(p,h);v=d.add(v,d.mul(f,h)),v=d.add(v,d.mul(w,S)),v=d.add(v,d.mul(w,G));let F=d.mul(g,h);F=d.add(F,d.mul(p,S)),F=d.add(F,d.mul(p,G)),F=d.add(F,d.mul(f,S)),F=d.add(F,d.mul(f,G)),F=d.add(F,d.mul(w,_));let E=d.mul(f,_);E=d.add(E,d.mul(p,_)),E=d.add(E,d.mul(g,G)),E=d.add(E,d.mul(g,S));let B=d.mul(g,_);return u=v,c&&(u=d.add(u,d.mul(m[c],F)),u=d.add(u,d.mul(b[c],E)),u=d.add(u,d.mul(y[c],B))),[l,u]}U=x.slice(0,(3*l.domainSize+6)*f),z.T1=await V(x.slice(0,l.domainSize*f),"multiexp T1"),z.T2=await V(x.slice(l.domainSize*f,2*l.domainSize*f),"multiexp T2"),z.T3=await V(x.slice(2*l.domainSize*f,(3*l.domainSize+6)*f),"multiexp T3")}(),await async function(){const t=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(t,0,l.domainSize*f,c[7][0].p);const a=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(a,0,l.domainSize*f,c[8][0].p);const n=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(n,0,l.domainSize*f,c[9][0].p);const i=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(i,0,l.domainSize*f,c[10][0].p);const o=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(o,0,l.domainSize*f,c[11][0].p);const u=new r.BigBuffer(l.domainSize*f);await s.readToBuffer(u,0,l.domainSize*f,c[12][0].p+10*l.domainSize*f);const p=new Uint8Array(2*w.F.n8*3);w.toRprUncompressed(p,0,z.T1),w.toRprUncompressed(p,2*w.F.n8,z.T2),w.toRprUncompressed(p,4*w.F.n8,z.T3),$.xi=W(p),e&&e.debug("xi: "+d.toString($.xi));z.eval_a=j(E,$.xi),z.eval_b=j(B,$.xi),z.eval_c=j(x,$.xi),z.eval_s1=j(T,$.xi),z.eval_s2=j(C,$.xi),z.eval_t=j(U,$.xi),z.eval_zw=j(A,d.mul($.xi,d.w[l.power]));const g=d.mul(z.eval_a,z.eval_b);let m=z.eval_a;const h=d.mul($.beta,$.xi);m=d.add(m,h),m=d.add(m,$.gamma);let b=z.eval_b;b=d.add(b,d.mul(h,l.k1)),b=d.add(b,$.gamma);let y=z.eval_c;y=d.add(y,d.mul(h,l.k2)),y=d.add(y,$.gamma);const G=d.mul(d.mul(d.mul(m,b),y),$.alpha);let S=z.eval_a;S=d.add(S,d.mul($.beta,z.eval_s1)),S=d.add(S,$.gamma);let _=z.eval_b;_=d.add(_,d.mul($.beta,z.eval_s2)),_=d.add(_,$.gamma);let v=d.mul(S,_);v=d.mul(v,$.beta),v=d.mul(v,z.eval_zw),v=d.mul(v,$.alpha),$.xim=$.xi;for(let e=0;e<l.power;e++)$.xim=d.mul($.xim,$.xim);const F=d.div(d.sub($.xim,d.one),d.mul(d.sub($.xi,d.one),d.e(l.domainSize))),R=d.mul(F,d.mul($.alpha,$.alpha)),k=v,I=d.add(G,R);L=new r.BigBuffer((l.domainSize+3)*f);for(let e=0;e<l.domainSize+3;e++){let r=d.mul(I,A.slice(e*f,(e+1)*f));e<l.domainSize&&(r=d.add(r,d.mul(g,t.slice(e*f,(e+1)*f))),r=d.add(r,d.mul(z.eval_a,a.slice(e*f,(e+1)*f))),r=d.add(r,d.mul(z.eval_b,n.slice(e*f,(e+1)*f))),r=d.add(r,d.mul(z.eval_c,i.slice(e*f,(e+1)*f))),r=d.add(r,o.slice(e*f,(e+1)*f)),r=d.sub(r,d.mul(k,u.slice(e*f,(e+1)*f)))),L.set(r,e*f)}z.eval_r=j(L,$.xi)}(),await async function(){const t=new Uint8Array(7*f);d.toRprBE(t,0,z.eval_a),d.toRprBE(t,f,z.eval_b),d.toRprBE(t,2*f,z.eval_c),d.toRprBE(t,3*f,z.eval_s1),d.toRprBE(t,4*f,z.eval_s2),d.toRprBE(t,5*f,z.eval_zw),d.toRprBE(t,6*f,z.eval_r),$.v=[],$.v[1]=W(t),e&&e.debug("v: "+d.toString($.v[1]));for(let e=2;e<=6;e++)$.v[e]=d.mul($.v[e-1],$.v[1]);let a=new r.BigBuffer((l.domainSize+6)*f);const n=d.mul($.xim,$.xim);for(let e=0;e<l.domainSize+6;e++){let t=d.zero;t=d.add(t,d.mul(n,U.slice((2*l.domainSize+e)*f,(2*l.domainSize+e+1)*f))),e<l.domainSize+3&&(t=d.add(t,d.mul($.v[1],L.slice(e*f,(e+1)*f)))),e<l.domainSize+2&&(t=d.add(t,d.mul($.v[2],E.slice(e*f,(e+1)*f))),t=d.add(t,d.mul($.v[3],B.slice(e*f,(e+1)*f))),t=d.add(t,d.mul($.v[4],x.slice(e*f,(e+1)*f)))),e<l.domainSize&&(t=d.add(t,U.slice(e*f,(e+1)*f)),t=d.add(t,d.mul($.xim,U.slice((l.domainSize+e)*f,(l.domainSize+e+1)*f))),t=d.add(t,d.mul($.v[5],T.slice(e*f,(e+1)*f))),t=d.add(t,d.mul($.v[6],C.slice(e*f,(e+1)*f)))),a.set(t,e*f)}let i=a.slice(0,f);i=d.sub(i,z.eval_t),i=d.sub(i,d.mul($.v[1],z.eval_r)),i=d.sub(i,d.mul($.v[2],z.eval_a)),i=d.sub(i,d.mul($.v[3],z.eval_b)),i=d.sub(i,d.mul($.v[4],z.eval_c)),i=d.sub(i,d.mul($.v[5],z.eval_s1)),i=d.sub(i,d.mul($.v[6],z.eval_s2)),a.set(i,0),a=H(a,$.xi),z.Wxi=await V(a,"multiexp Wxi");let o=new r.BigBuffer((l.domainSize+3)*f);for(let e=0;e<l.domainSize+3;e++){const t=A.slice(e*f,(e+1)*f);o.set(t,e*f)}i=o.slice(0,f),i=d.sub(i,z.eval_zw),o.set(i,0),o=H(o,d.mul($.xi,d.w[l.power])),z.Wxiw=await V(o,"multiexp Wxiw")}(),z.protocol="plonk",z.curve=u.name,await s.close(),await n.close();let O=[];for(let g=1;g<=l.nPublic;g++){const t=p.slice(g*d.n8,g*d.n8+d.n8);O.push(r.Scalar.fromRprLE(t))}return z.A=w.toObject(z.A),z.B=w.toObject(z.B),z.C=w.toObject(z.C),z.Z=w.toObject(z.Z),z.T1=w.toObject(z.T1),z.T2=w.toObject(z.T2),z.T3=w.toObject(z.T3),z.eval_a=d.toObject(z.eval_a),z.eval_b=d.toObject(z.eval_b),z.eval_c=d.toObject(z.eval_c),z.eval_s1=d.toObject(z.eval_s1),z.eval_s2=d.toObject(z.eval_s2),z.eval_zw=d.toObject(z.eval_zw),z.eval_t=d.toObject(z.eval_t),z.eval_r=d.toObject(z.eval_r),z.Wxi=w.toObject(z.Wxi),z.Wxiw=w.toObject(z.Wxiw),delete z.eval_t,z=Ot(z),O=Ot(O),{proof:z,publicSignals:O};function P(t,a){const e=t.slice(a,a+4);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint32(0,!0)}function q(t){return t<l.nVars-l.nAdditions?p.slice(t*f,t*f+f):t<l.nVars?m.slice((t-(l.nVars-l.nAdditions))*f,(t-(l.nVars-l.nAdditions))*f+f):u.Fr.zero}function W(t){const a=r.Scalar.fromRprBE(new Uint8Array(Mt.arrayBuffer(t)));return d.e(a)}function j(t,a){const e=t.byteLength/f;if(0==e)return d.zero;let n=t.slice((e-1)*f,e*f);for(let i=e-2;i>=0;i--)n=d.add(d.mul(n,a),t.slice(i*f,(i+1)*f));return n}function H(t,a){const e=t.byteLength/f,n=new r.BigBuffer(e*f);n.set(d.zero,(e-1)*f),n.set(t.slice((e-1)*f,e*f),(e-2)*f);for(let i=e-3;i>=0;i--)n.set(d.add(t.slice((i+1)*f,(i+2)*f),d.mul(a,n.slice((i+1)*f,(i+2)*f))),i*f);if(!d.eq(t.slice(0,f),d.mul(d.neg(a),n.slice(0,f))))throw new Error("Polinomial does not divide");return n}async function V(t,a){const n=t.byteLength/f,i=I.slice(0,n*u.G1.F.n8*2),r=await u.Fr.batchFromMontgomery(t);let o=await u.G1.multiExpAffine(i,r,e,a);return o=u.G1.toAffine(o),o}async function K(t,a){a=a||[];let e=await d.ifft(t);const n=new r.BigBuffer(f*l.domainSize*4);n.set(e,0);const i=new r.BigBuffer(f*(l.domainSize+a.length));i.set(e,0);for(let r=0;r<a.length;r++)i.set(d.add(i.slice((l.domainSize+r)*f,(l.domainSize+r+1)*f),a[r]),(l.domainSize+r)*f),i.set(d.sub(i.slice(r*f,(r+1)*f),a[r]),r*f);return[i,await d.fft(n)]}}const{unstringifyBigInts:qt}=r.utils;const{unstringifyBigInts:Wt}=r.utils,{keccak256:jt}=G.default;function Ht(t,a){const e=r.Scalar.fromRprBE(new Uint8Array(jt.arrayBuffer(a)));return t.Fr.e(e)}const{unstringifyBigInts:Vt}=r.utils;function Nt(t){return("0"+t.toString(16)).slice(-2)}function Kt(t){let a=t.toString(16);for(;a.length<64;)a="0"+a;return a=`"0x${a}"`,a}var Dt=Object.freeze({__proto__:null,setup:async function(t,a,e,n){globalThis.gc&&globalThis.gc(),await m.default.ready();const{fd:o,sections:s}=await i.readBinFile(a,"ptau",1,1<<22,1<<24),{curve:c,power:l}=await st(o,s),{fd:d,sections:w}=await i.readBinFile(t,"r1cs",1,1<<22,1<<24),f=await u.readR1csHeader(d,w,!1),p=2*c.G1.F.n8,g=c.G1,h=2*c.G2.F.n8,b=c.Fr,y=c.Fr.n8;n&&n.info("Reading r1cs");let G=await i.readSection(d,w,2);const S=new zt,_=new zt;let v=f.nVars;const F=f.nOutputs+f.nPubInputs;await async function(){let t=0;function a(){const a=G.slice(t,t+4);t+=4;return new DataView(a.buffer).getUint32(0,!0)}function e(){const a=b.fromRprLE(G.slice(t,t+c.Fr.n8));return t+=c.Fr.n8,a}function i(){const t=[],n={k:c.Fr.zero},i=a();for(let r=0;r<i;r++){const i=a(),r=e();0==i?n.k=r:t.push([i,r])}const o=r(t);return n.s=o[0],n.coef=o[1],n}function r(t){if(0==t.length)return[0,c.Fr.zero];if(1==t.length)return t[0];const a=t.slice(0,t.length>>1),e=t.slice(t.length>>1),n=r(a),i=r(e),o=n[0],s=i[0],l=v++,u=c.Fr.zero,d=b.neg(n[1]),w=b.neg(i[1]),f=c.Fr.one,p=c.Fr.zero;return S.push([o,s,l,u,d,w,f,p]),_.push([o,s,n[1],i[1]]),[l,c.Fr.one]}for(let n=1;n<=F;n++){const t=n,a=0,e=0,i=c.Fr.zero,r=c.Fr.one,o=c.Fr.zero,s=c.Fr.zero,l=c.Fr.zero;S.push([t,a,e,i,r,o,s,l])}for(let o=0;o<f.nConstraints;o++){n&&o%1e4==0&&n.debug(`processing constraints: ${o}/${f.nConstraints}`);const t=i(),a=i(),e=i(),r=t.s,s=a.s,l=e.s,u=c.Fr.mul(t.coef,a.coef),d=c.Fr.mul(t.coef,a.k),w=c.Fr.mul(t.k,a.coef),p=c.Fr.neg(e.coef),g=c.Fr.sub(c.Fr.mul(t.k,a.k),e.k);S.push([r,s,l,u,d,w,p,g])}}(),globalThis.gc&&globalThis.gc();const B=await i.createBinFile(e,"zkey",1,14,1<<22,1<<24);if(f.prime!=c.r)return n&&n.error("r1cs curve does not match powers of tau ceremony curve"),-1;let x=E(S.length-1)+1;x<3&&(x=3);const A=2**x;if(n&&n.info("Plonk constraints: "+S.length),x>l)return n&&n.error(`circuit too big for this power of tau ceremony. ${S.length} > 2**${l}`),-1;if(!s[12])return n&&n.error("Powers of tau is not prepared."),-1;const U=new r.BigBuffer(A*p),L=s[12][0].p+(2**x-1)*p;await o.readToBuffer(U,0,A*p,L);const[z,R]=function(){let t=b.two;for(;e(t,[],x);)b.add(t,b.one);let a=b.add(t,b.one);for(;e(a,[t],x);)b.add(a,b.one);return[t,a];function e(t,a,e){const n=2**e;let i=b.one;for(let r=0;r<n;r++){if(b.eq(t,i))return!0;for(let e=0;e<a.length;e++)if(b.eq(t,b.mul(a[e],i)))return!0;i=b.mul(i,b.w[e])}return!1}}(),k={};await async function(t,a){await i.startWriteSection(B,t);const e=new Uint8Array(8+2*y),r=new DataView(e.buffer);for(let i=0;i<_.length;i++){const t=_[i];let o=0;r.setUint32(o,t[0],!0),o+=4,r.setUint32(o,t[1],!0),o+=4,e.set(t[2],o),o+=y,e.set(t[3],o),o+=y,await B.write(e),n&&i%1e6==0&&n.debug(`writing ${a}: ${i}/${_.length}`)}await i.endWriteSection(B)}(3,"Additions"),globalThis.gc&&globalThis.gc(),await C(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await C(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await C(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await I(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await I(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await I(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await I(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await I(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await async function(t,a){const e=new r.BigBuffer(y*A*3),o=new zt(v),s=new zt(v);let l=b.one;for(let i=0;i<A;i++)i<S.length?(f(S[i][0],i),f(S[i][1],A+i),f(S[i][2],2*A+i)):(f(0,i),f(0,A+i),f(0,2*A+i)),l=b.mul(l,b.w[x]),n&&i%1e6==0&&n.debug(`writing ${a} phase1: ${i}/${S.length}`);for(let i=0;i<v;i++)"undefined"!==typeof s[i]?e.set(o[i],s[i]*y):console.log("Variable not used"),n&&i%1e6==0&&n.debug(`writing ${a} phase2: ${i}/${v}`);globalThis.gc&&globalThis.gc();await i.startWriteSection(B,t);let u=e.slice(0,A*y);await $(u),globalThis.gc&&globalThis.gc();let d=e.slice(A*y,A*y*2);await $(d),globalThis.gc&&globalThis.gc();let w=e.slice(A*y*2,A*y*3);await $(w),globalThis.gc&&globalThis.gc();await i.endWriteSection(B),u=await b.batchFromMontgomery(u),d=await b.batchFromMontgomery(d),w=await b.batchFromMontgomery(w),k.S1=await c.G1.multiExpAffine(U,u,n,"multiexp S1"),globalThis.gc&&globalThis.gc();k.S2=await c.G1.multiExpAffine(U,d,n,"multiexp S2"),globalThis.gc&&globalThis.gc();k.S3=await c.G1.multiExpAffine(U,w,n,"multiexp S3"),globalThis.gc&&globalThis.gc();function f(t,a){let n;"undefined"===typeof o[t]?s[t]=a:e.set(o[t],a*y),n=a<A?l:a<2*A?b.mul(l,z):b.mul(l,R),o[t]=n}}(12,"sigma"),globalThis.gc&&globalThis.gc(),await async function(t,a){await i.startWriteSection(B,t);const e=Math.max(F,1);for(let i=0;i<e;i++){let t=new r.BigBuffer(A*y);t.set(b.one,i*y),await $(t),n&&n.debug(`writing ${a} ${i}/${e}`)}await i.endWriteSection(B)}(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await i.startWriteSection(B,14);const T=new r.BigBuffer((A+6)*p);return await o.readToBuffer(T,0,(A+6)*p,s[2][0].p),await B.write(T),await i.endWriteSection(B),globalThis.gc&&globalThis.gc(),await async function(){await i.startWriteSection(B,1),await B.writeULE32(2),await i.endWriteSection(B),await i.startWriteSection(B,2);const t=c.q,a=8*(Math.floor((r.Scalar.bitLength(t)-1)/64)+1),e=c.r,n=8*(Math.floor((r.Scalar.bitLength(e)-1)/64)+1);let l;await B.writeULE32(a),await i.writeBigInt(B,t,a),await B.writeULE32(n),await i.writeBigInt(B,e,n),await B.writeULE32(v),await B.writeULE32(F),await B.writeULE32(A),await B.writeULE32(_.length),await B.writeULE32(S.length),await B.write(z),await B.write(R),await B.write(g.toAffine(k.Qm)),await B.write(g.toAffine(k.Ql)),await B.write(g.toAffine(k.Qr)),await B.write(g.toAffine(k.Qo)),await B.write(g.toAffine(k.Qc)),await B.write(g.toAffine(k.S1)),await B.write(g.toAffine(k.S2)),await B.write(g.toAffine(k.S3)),l=await o.read(h,s[3][0].p+h),await B.write(l),await i.endWriteSection(B)}(),await B.close(),await d.close(),await o.close(),void(n&&n.info("Setup Finished"));async function C(t,a,e){await i.startWriteSection(B,t);for(let i=0;i<S.length;i++)await B.writeULE32(S[i][a]),n&&i%1e6==0&&n.debug(`writing ${e}: ${i}/${S.length}`);await i.endWriteSection(B)}async function I(t,a,e){let o=new r.BigBuffer(A*y);for(let i=0;i<S.length;i++)o.set(S[i][a],i*y),n&&i%1e6==0&&n.debug(`writing ${e}: ${i}/${S.length}`);await i.startWriteSection(B,t),await $(o),await i.endWriteSection(B),o=await b.batchFromMontgomery(o),k[e]=await c.G1.multiExpAffine(U,o,n,"multiexp "+e)}async function $(t){const a=await b.ifft(t),e=new r.BigBuffer(A*y*4);e.set(a,0);const n=await b.fft(e);await B.write(a),await B.write(n)}},fullProve:async function(t,a,e,n){const i=qt(t),r={type:"mem"};return await Z(i,a,r),await Pt(e,r,n)},prove:Pt,verify:async function(t,a,e,n){let i=Wt(t),r=Wt(e),o=Wt(a);const s=await F(i.curve),c=s.Fr,l=s.G1;if(r=function(t,a){const e=t.G1,n=t.Fr,i={};return i.A=e.fromObject(a.A),i.B=e.fromObject(a.B),i.C=e.fromObject(a.C),i.Z=e.fromObject(a.Z),i.T1=e.fromObject(a.T1),i.T2=e.fromObject(a.T2),i.T3=e.fromObject(a.T3),i.eval_a=n.fromObject(a.eval_a),i.eval_b=n.fromObject(a.eval_b),i.eval_c=n.fromObject(a.eval_c),i.eval_zw=n.fromObject(a.eval_zw),i.eval_s1=n.fromObject(a.eval_s1),i.eval_s2=n.fromObject(a.eval_s2),i.eval_r=n.fromObject(a.eval_r),i.Wxi=e.fromObject(a.Wxi),i.Wxiw=e.fromObject(a.Wxiw),i}(s,r),i=function(t,a){const e=t.G1,n=t.G2,i=t.Fr,r=a;return r.Qm=e.fromObject(a.Qm),r.Ql=e.fromObject(a.Ql),r.Qr=e.fromObject(a.Qr),r.Qo=e.fromObject(a.Qo),r.Qc=e.fromObject(a.Qc),r.S1=e.fromObject(a.S1),r.S2=e.fromObject(a.S2),r.S3=e.fromObject(a.S3),r.k1=i.fromObject(a.k1),r.k2=i.fromObject(a.k2),r.X_2=n.fromObject(a.X_2),r}(s,i),!function(t,a){const e=t.G1;return!!e.isValid(a.A)&&(!!e.isValid(a.B)&&(!!e.isValid(a.C)&&(!!e.isValid(a.Z)&&(!!e.isValid(a.T1)&&(!!e.isValid(a.T2)&&(!!e.isValid(a.T3)&&(!!e.isValid(a.Wxi)&&!!e.isValid(a.Wxiw))))))))}(s,r))return n.error("Proof is not well constructed"),!1;if(o.length!=i.nPublic)return n.error("Invalid number of public inputs"),!1;const u=function(t,a,e){const n=t.G1,i=t.Fr,r=t.Fr.n8,o={},s=new Uint8Array(e.length*r+2*n.F.n8*3);for(let f=0;f<e.length;f++)i.toRprBE(s,f*r,i.e(e[f]));n.toRprUncompressed(s,e.length*r+0,a.A),n.toRprUncompressed(s,e.length*r+2*n.F.n8,a.B),n.toRprUncompressed(s,e.length*r+4*n.F.n8,a.C),o.beta=Ht(t,s);const c=new Uint8Array(r);i.toRprBE(c,0,o.beta),o.gamma=Ht(t,c);const l=new Uint8Array(2*n.F.n8);n.toRprUncompressed(l,0,a.Z),o.alpha=Ht(t,l);const u=new Uint8Array(2*n.F.n8*3);n.toRprUncompressed(u,0,a.T1),n.toRprUncompressed(u,2*n.F.n8,a.T2),n.toRprUncompressed(u,4*n.F.n8,a.T3),o.xi=Ht(t,u);const d=new Uint8Array(7*r);i.toRprBE(d,0,a.eval_a),i.toRprBE(d,r,a.eval_b),i.toRprBE(d,2*r,a.eval_c),i.toRprBE(d,3*r,a.eval_s1),i.toRprBE(d,4*r,a.eval_s2),i.toRprBE(d,5*r,a.eval_zw),i.toRprBE(d,6*r,a.eval_r),o.v=[],o.v[1]=Ht(t,d);for(let f=2;f<=6;f++)o.v[f]=i.mul(o.v[f-1],o.v[1]);const w=new Uint8Array(2*n.F.n8*2);return n.toRprUncompressed(w,0,a.Wxi),n.toRprUncompressed(w,2*n.F.n8,a.Wxiw),o.u=Ht(t,w),o}(s,r,o);n&&(n.debug("beta: "+c.toString(u.beta,16)),n.debug("gamma: "+c.toString(u.gamma,16)),n.debug("alpha: "+c.toString(u.alpha,16)),n.debug("xi: "+c.toString(u.xi,16)),n.debug("v1: "+c.toString(u.v[1],16)),n.debug("v6: "+c.toString(u.v[6],16)),n.debug("u: "+c.toString(u.u,16)));const d=function(t,a,e){const n=t.Fr;let i=a.xi,r=1;for(let l=0;l<e.power;l++)i=n.square(i),r*=2;a.xin=i,a.zh=n.sub(i,n.one);const o=[],s=n.e(r);let c=n.one;for(let l=1;l<=Math.max(1,e.nPublic);l++)o[l]=n.div(n.mul(c,a.zh),n.mul(s,n.sub(a.xi,c))),c=n.mul(c,n.w[e.power]);return o}(s,u,i);if(n){n.debug("Lagrange Evaluations: ");for(let t=1;t<d.length;t++)n.debug(`L${t}(xi)=`+c.toString(d[t],16))}if(o.length!=i.nPublic)return n.error("Number of public signals does not match with vk"),!1;const w=function(t,a,e){const n=t.Fr;let i=n.zero;for(let r=0;r<a.length;r++){const t=n.e(a[r]);i=n.sub(i,n.mul(t,e[r+1]))}return i}(s,o,d);n&&n.debug("Pl: "+c.toString(w,16));const f=function(t,a,e,n,i){const r=t.Fr;let o=a.eval_r;o=r.add(o,n);let s=a.eval_a;s=r.add(s,r.mul(e.beta,a.eval_s1)),s=r.add(s,e.gamma);let c=a.eval_b;c=r.add(c,r.mul(e.beta,a.eval_s2)),c=r.add(c,e.gamma);let l=a.eval_c;l=r.add(l,e.gamma);let u=r.mul(r.mul(s,c),l);u=r.mul(u,a.eval_zw),u=r.mul(u,e.alpha),o=r.sub(o,u),o=r.sub(o,r.mul(i,r.square(e.alpha)));return r.div(o,e.zh)}(s,r,u,w,d[1]);n&&n.debug("t: "+c.toString(f,16));const p=function(t,a,e,n,i){const r=t.G1,o=t.Fr;let s=o.mul(o.mul(a.eval_a,a.eval_b),e.v[1]),c=r.timesFr(n.Qm,s),l=o.mul(a.eval_a,e.v[1]);c=r.add(c,r.timesFr(n.Ql,l));let u=o.mul(a.eval_b,e.v[1]);c=r.add(c,r.timesFr(n.Qr,u));let d=o.mul(a.eval_c,e.v[1]);c=r.add(c,r.timesFr(n.Qo,d)),c=r.add(c,r.timesFr(n.Qc,e.v[1]));const w=o.mul(e.beta,e.xi);let f=a.eval_a;f=o.add(f,w),f=o.add(f,e.gamma);let p=a.eval_b;p=o.add(p,o.mul(w,n.k1)),p=o.add(p,e.gamma);let g=a.eval_c;g=o.add(g,o.mul(w,n.k2)),g=o.add(g,e.gamma);let m=o.mul(o.mul(f,p),g);m=o.mul(m,o.mul(e.alpha,e.v[1]));let h=o.mul(o.mul(i,o.square(e.alpha)),e.v[1]);m=o.add(m,h),m=o.add(m,e.u),c=r.add(c,r.timesFr(a.Z,m));let b=a.eval_a;b=o.add(b,o.mul(e.beta,a.eval_s1)),b=o.add(b,e.gamma);let y=a.eval_b;y=o.add(y,o.mul(e.beta,a.eval_s2)),y=o.add(y,e.gamma);let G=o.mul(b,y);return G=o.mul(G,e.alpha),G=o.mul(G,e.v[1]),G=o.mul(G,e.beta),G=o.mul(G,a.eval_zw),c=r.sub(c,r.timesFr(n.S3,G)),c}(s,r,u,i,d[1]);n&&n.debug("D: "+l.toString(l.toAffine(p),16));const g=function(t,a,e,n,i){const r=t.G1,o=t.Fr;let s=a.T1;return s=r.add(s,r.timesFr(a.T2,e.xin)),s=r.add(s,r.timesFr(a.T3,o.square(e.xin))),s=r.add(s,i),s=r.add(s,r.timesFr(a.A,e.v[2])),s=r.add(s,r.timesFr(a.B,e.v[3])),s=r.add(s,r.timesFr(a.C,e.v[4])),s=r.add(s,r.timesFr(n.S1,e.v[5])),s=r.add(s,r.timesFr(n.S2,e.v[6])),s}(s,r,u,i,p);n&&n.debug("F: "+l.toString(l.toAffine(g),16));const m=function(t,a,e,n,i){const r=t.G1,o=t.Fr;let s=i;s=o.add(s,o.mul(e.v[1],a.eval_r)),s=o.add(s,o.mul(e.v[2],a.eval_a)),s=o.add(s,o.mul(e.v[3],a.eval_b)),s=o.add(s,o.mul(e.v[4],a.eval_c)),s=o.add(s,o.mul(e.v[5],a.eval_s1)),s=o.add(s,o.mul(e.v[6],a.eval_s2)),s=o.add(s,o.mul(e.u,a.eval_zw));return r.timesFr(r.one,s)}(s,r,u,0,f);n&&n.debug("E: "+l.toString(l.toAffine(m),16));const h=await async function(t,a,e,n,i,r){const o=t.G1,s=t.Fr;let c=a.Wxi;c=o.add(c,o.timesFr(a.Wxiw,e.u));let l=o.timesFr(a.Wxi,e.xi);const u=s.mul(s.mul(e.u,e.xi),s.w[n.power]);l=o.add(l,o.timesFr(a.Wxiw,u)),l=o.add(l,r),l=o.sub(l,i);return await t.pairingEq(o.neg(c),n.X_2,l,t.G2.one)}(s,r,u,i,m,g);return n&&(h?n.info("OK!"):n.warn("Invalid Proof")),h},exportSolidityCallData:async function(t,a){const e=Vt(t),n=Vt(a),i=await F(e.curve),r=i.G1,o=i.Fr;let s="";for(let l=0;l<n.length;l++)""!=s&&(s+=","),s+=Kt(n[l]);const c=new Uint8Array(2*r.F.n8*9+7*o.n8);return r.toRprUncompressed(c,0,r.e(e.A)),r.toRprUncompressed(c,2*r.F.n8,r.e(e.B)),r.toRprUncompressed(c,4*r.F.n8,r.e(e.C)),r.toRprUncompressed(c,6*r.F.n8,r.e(e.Z)),r.toRprUncompressed(c,8*r.F.n8,r.e(e.T1)),r.toRprUncompressed(c,10*r.F.n8,r.e(e.T2)),r.toRprUncompressed(c,12*r.F.n8,r.e(e.T3)),r.toRprUncompressed(c,14*r.F.n8,r.e(e.Wxi)),r.toRprUncompressed(c,16*r.F.n8,r.e(e.Wxiw)),o.toRprBE(c,18*r.F.n8,o.e(e.eval_a)),o.toRprBE(c,18*r.F.n8+o.n8,o.e(e.eval_b)),o.toRprBE(c,18*r.F.n8+2*o.n8,o.e(e.eval_c)),o.toRprBE(c,18*r.F.n8+3*o.n8,o.e(e.eval_s1)),o.toRprBE(c,18*r.F.n8+4*o.n8,o.e(e.eval_s2)),o.toRprBE(c,18*r.F.n8+5*o.n8,o.e(e.eval_zw)),o.toRprBE(c,18*r.F.n8+6*o.n8,o.e(e.eval_r)),"0x"+Array.from(c).map(Nt).join("")+",["+s+"]"}});a.groth16=at,a.plonk=Dt,a.powersOfTau=Gt,a.r1cs=Ft,a.wtns=xt,a.zKey=$t}}]);