"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[808],{496:function(t,e,i){Object.defineProperty(e,"__esModule",{value:!0});var s=i(4736),n=(i(2474),i(7571)),r=i(3461),h=i(4763),o=i(4659);function f(t){return t&&"object"===typeof t&&"default"in t?t:{default:t}}var u=f(s),a=f(r),l=f(h);const p=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];function c(t,e){return e&&10!=e?16==e?"0x"==t.slice(0,2)?BigInt(t):BigInt("0x"+t):void 0:BigInt(t)}const m=c;function g(t,e){return BigInt(t)<<BigInt(e)}function d(t,e){return BigInt(t)>>BigInt(e)}const F=g,b=d;var y=Object.freeze({__proto__:null,fromString:c,e:m,fromArray:function(t,e){let i=BigInt(0);e=BigInt(e);for(let s=0;s<t.length;s++)i=i*e+BigInt(t[s]);return i},bitLength:function(t){const e=t.toString(16);return 4*(e.length-1)+p[parseInt(e[0],16)]},isNegative:function(t){return BigInt(t)<BigInt(0)},isZero:function(t){return!t},shiftLeft:g,shiftRight:d,shl:F,shr:b,isOdd:function(t){return(BigInt(t)&BigInt(1))==BigInt(1)},naf:function(t){let e=BigInt(t);const i=[];for(;e;){if(e&BigInt(1)){const t=2-Number(e%BigInt(4));i.push(t),e-=BigInt(t)}else i.push(0);e>>=BigInt(1)}return i},bits:function(t){let e=BigInt(t);const i=[];for(;e;)e&BigInt(1)?i.push(1):i.push(0),e>>=BigInt(1);return i},toNumber:function(t){if(t>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Number too big");return Number(t)},toArray:function(t,e){const i=[];let s=BigInt(t);for(e=BigInt(e);s;)i.unshift(Number(s%e)),s/=e;return i},add:function(t,e){return BigInt(t)+BigInt(e)},sub:function(t,e){return BigInt(t)-BigInt(e)},neg:function(t){return-BigInt(t)},mul:function(t,e){return BigInt(t)*BigInt(e)},square:function(t){return BigInt(t)*BigInt(t)},pow:function(t,e){return BigInt(t)**BigInt(e)},exp:function(t,e){return BigInt(t)**BigInt(e)},abs:function(t){return BigInt(t)>=0?BigInt(t):-BigInt(t)},div:function(t,e){return BigInt(t)/BigInt(e)},mod:function(t,e){return BigInt(t)%BigInt(e)},eq:function(t,e){return BigInt(t)==BigInt(e)},neq:function(t,e){return BigInt(t)!=BigInt(e)},lt:function(t,e){return BigInt(t)<BigInt(e)},gt:function(t,e){return BigInt(t)>BigInt(e)},leq:function(t,e){return BigInt(t)<=BigInt(e)},geq:function(t,e){return BigInt(t)>=BigInt(e)},band:function(t,e){return BigInt(t)&BigInt(e)},bor:function(t,e){return BigInt(t)|BigInt(e)},bxor:function(t,e){return BigInt(t)^BigInt(e)},land:function(t,e){return BigInt(t)&&BigInt(e)},lor:function(t,e){return BigInt(t)||BigInt(e)},lnot:function(t){return!BigInt(t)}});function w(t,e){return"string"==typeof t&&"0x"==t.slice(0,2)?u.default(t.slice(2),16):u.default(t,e)}const L=w;function v(t,e){return u.default(t).shiftLeft(e)}function B(t,e){return u.default(t).shiftRight(e)}const q=v,E=B;var O=Object.freeze({__proto__:null,fromString:w,e:L,fromArray:function(t,e){return u.default.fromArray(t,e)},bitLength:function(t){return u.default(t).bitLength()},isNegative:function(t){return u.default(t).isNegative()},isZero:function(t){return u.default(t).isZero()},shiftLeft:v,shiftRight:B,shl:q,shr:E,isOdd:function(t){return u.default(t).isOdd()},naf:function(t){let e=u.default(t);const i=[];for(;e.gt(u.default.zero);){if(e.isOdd()){const t=2-e.mod(4).toJSNumber();i.push(t),e=e.minus(t)}else i.push(0);e=e.shiftRight(1)}return i},bits:function(t){let e=u.default(t);const i=[];for(;e.gt(u.default.zero);)e.isOdd()?i.push(1):i.push(0),e=e.shiftRight(1);return i},toNumber:function(t){if(!t.lt(u.default("9007199254740992",10)))throw new Error("Number too big");return t.toJSNumber()},toArray:function(t,e){return u.default(t).toArray(e)},add:function(t,e){return u.default(t).add(u.default(e))},sub:function(t,e){return u.default(t).minus(u.default(e))},neg:function(t){return u.default.zero.minus(u.default(t))},mul:function(t,e){return u.default(t).times(u.default(e))},square:function(t){return u.default(t).square()},pow:function(t,e){return u.default(t).pow(u.default(e))},exp:function(t,e){return u.default(t).pow(u.default(e))},abs:function(t){return u.default(t).abs()},div:function(t,e){return u.default(t).divide(u.default(e))},mod:function(t,e){return u.default(t).mod(u.default(e))},eq:function(t,e){return u.default(t).eq(u.default(e))},neq:function(t,e){return u.default(t).neq(u.default(e))},lt:function(t,e){return u.default(t).lt(u.default(e))},gt:function(t,e){return u.default(t).gt(u.default(e))},leq:function(t,e){return u.default(t).leq(u.default(e))},geq:function(t,e){return u.default(t).geq(u.default(e))},band:function(t,e){return u.default(t).and(u.default(e))},bor:function(t,e){return u.default(t).or(u.default(e))},bxor:function(t,e){return u.default(t).xor(u.default(e))},land:function(t,e){return!u.default(t).isZero()&&!u.default(e).isZero()},lor:function(t,e){return!u.default(t).isZero()||!u.default(e).isZero()},lnot:function(t){return u.default(t).isZero()}});const _="function"===typeof BigInt;let A={};_?Object.assign(A,y):Object.assign(A,O),A.toRprLE=function(t,e,i,s){const n="0000000"+i.toString(16),r=new Uint32Array(t.buffer,e,s/4),h=1+(4*(n.length-7)-1>>5);for(let o=0;o<h;o++)r[o]=parseInt(n.substring(n.length-8*o-8,n.length-8*o),16);for(let o=h;o<r.length;o++)r[o]=0;for(let o=4*r.length;o<s;o++)t[o]=A.toNumber(A.band(A.shiftRight(i,8*o),255))},A.toRprBE=function(t,e,i,s){const n="0000000"+i.toString(16),r=new DataView(t.buffer,t.byteOffset+e,s),h=1+(4*(n.length-7)-1>>5);for(let o=0;o<h;o++)r.setUint32(s-4*o-4,parseInt(n.substring(n.length-8*o-8,n.length-8*o),16),!1);for(let o=0;o<s/4-h;o++)r[o]=0},A.fromRprLE=function(t,e,i){i=i||t.byteLength,e=e||0;const s=new Uint32Array(t.buffer,e,i/4),n=new Array(i/4);return s.forEach(((t,e)=>n[n.length-e-1]=t.toString(16).padStart(8,"0"))),A.fromString(n.join(""),16)},A.fromRprBE=function(t,e,i){i=i||t.byteLength,e=e||0;const s=new DataView(t.buffer,t.byteOffset+e,i),n=new Array(i/4);for(let r=0;r<i/4;r++)n[r]=s.getUint32(4*r,!1).toString(16).padStart(8,"0");return A.fromString(n.join(""),16)},A.toString=function(t,e){return t.toString(e)},A.toLEBuff=function(t){const e=new Uint8Array(Math.floor((A.bitLength(t)-1)/8)+1);return A.toRprLE(e,0,t,e.byteLength),e},A.zero=A.e(0),A.one=A.e(1);let{toRprLE:R,toRprBE:x,fromRprLE:z,fromRprBE:I,toString:M,toLEBuff:S,zero:T,one:G,fromString:U,e:N,fromArray:C,bitLength:j,isNegative:Z,isZero:k,shiftLeft:$,shiftRight:P,shl:J,shr:D,isOdd:Q,naf:X,bits:V,toNumber:W,toArray:K,add:H,sub:Y,neg:tt,mul:et,square:it,pow:st,exp:nt,abs:rt,div:ht,mod:ot,eq:ft,neq:ut,lt:at,gt:lt,leq:pt,geq:ct,band:mt,bor:gt,bxor:dt,land:Ft,lor:bt,lnot:yt}=A;var wt=Object.freeze({__proto__:null,toRprLE:R,toRprBE:x,fromRprLE:z,fromRprBE:I,toString:M,toLEBuff:S,zero:T,one:G,fromString:U,e:N,fromArray:C,bitLength:j,isNegative:Z,isZero:k,shiftLeft:$,shiftRight:P,shl:J,shr:D,isOdd:Q,naf:X,bits:V,toNumber:W,toArray:K,add:H,sub:Y,neg:tt,mul:et,square:it,pow:st,exp:nt,abs:rt,div:ht,mod:ot,eq:ft,neq:ut,lt:at,gt:lt,leq:pt,geq:ct,band:mt,bor:gt,bxor:dt,land:Ft,lor:bt,lnot:yt});function Lt(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)}function vt(t,e,i,s,n){const r=1<<i;if(1==r)return[e[s]];if(2==r)return[t.F.add(e[s],e[s+n]),t.F.sub(e[s],e[s+n])];const h=r>>1,o=vt(t,e,i-1,s,2*n),f=vt(t,e,i-1,s+n,2*n),u=new Array(r);for(let a=0;a<h;a++)u[a]=t.F.add(o[a],t.F.mul(t.roots[i][a],f[a])),u[a+h]=t.F.sub(o[a],t.F.mul(t.roots[i][a],f[a]));return u}function Bt(t,e,i){const s=1<<i;if(1==s)return[e[0]];const n=s>>1,r=Bt(t,e.slice(0,n),i-1),h=Bt(t,e.slice(n),i-1),o=new Array(s);for(let f=0;f<n;f++)o[f]=t.F.add(r[f],t.F.mul(t.roots[i][f],h[f])),o[f+n]=t.F.sub(r[f],t.F.mul(t.roots[i][f],h[f]));return o}const qt=[];for(let Ge=0;Ge<256;Ge++)qt[Ge]=Et(Ge,8);function Et(t,e){let i=0,s=t;for(let n=0;n<e;n++)i<<=1,i|=1&s,s>>=1;return i}function Ot(t,e){return(qt[t>>>24]|qt[t>>>16&255]<<8|qt[t>>>8&255]<<16|qt[255&t]<<24)>>>32-e}function _t(t,e){for(let i=0;i<t.length;i++){const s=Ot(i,e);if(s>i){const e=t[i];t[i]=t[s],t[s]=e}}}function At(t,e,i){let s;if(k(i))return t.zero;const n=X(i);if(1==n[n.length-1])s=e;else{if(-1!=n[n.length-1])throw new Error("invlaud NAF");s=t.neg(e)}for(let r=n.length-2;r>=0;r--)s=t.double(s),1==n[r]?s=t.add(s,e):-1==n[r]&&(s=t.sub(s,e));return s}function Rt(t,e,i){if(k(i))return t.one;const s=V(i);if(0==s.length)return t.one;let n=e;for(let r=s.length-2;r>=0;r--)n=t.square(n),s[r]&&(n=t.mul(n,e));return n}function xt(t){if(t.m%2==1)if(ft(ot(t.p,4),1))if(ft(ot(t.p,8),1))if(ft(ot(t.p,16),1))!function(t){t.sqrt_q=st(t.p,t.m),t.sqrt_s=0,t.sqrt_t=Y(t.sqrt_q,1);for(;!Q(t.sqrt_t);)t.sqrt_s=t.sqrt_s+1,t.sqrt_t=ht(t.sqrt_t,2);let e=t.one;for(;t.eq(e,t.one);){const i=t.random();t.sqrt_z=t.pow(i,t.sqrt_t),e=t.pow(t.sqrt_z,2**(t.sqrt_s-1))}t.sqrt_tm1d2=ht(Y(t.sqrt_t,1),2),t.sqrt=function(t){const e=this;if(e.isZero(t))return e.zero;let i=e.pow(t,e.sqrt_tm1d2);const s=e.pow(e.mul(e.square(i),t),2**(e.sqrt_s-1));if(e.eq(s,e.negone))return null;let n=e.sqrt_s,r=e.mul(t,i),h=e.mul(r,i),o=e.sqrt_z;for(;!e.eq(h,e.one);){let t=e.square(h),s=1;for(;!e.eq(t,e.one);)t=e.square(t),s++;i=o;for(let r=0;r<n-s-1;r++)i=e.square(i);o=e.square(i),h=e.mul(h,o),r=e.mul(r,i),n=s}return e.geq(r,e.zero)?r:e.neg(r)}}(t);else{if(!ft(ot(t.p,16),9))throw new Error("Field withot sqrt");!function(t){t.sqrt=function(){throw new Error("Sqrt alg 4 not implemented")}}(t)}else{if(!ft(ot(t.p,8),5))throw new Error("Field withot sqrt");!function(t){t.sqrt=function(){throw new Error("Sqrt alg 3 not implemented")}}(t)}else ft(ot(t.p,4),3)&&function(t){t.sqrt_q=st(t.p,t.m),t.sqrt_e1=ht(Y(t.sqrt_q,3),4),t.sqrt=function(e){if(this.isZero(e))return this.zero;const i=this.pow(e,this.sqrt_e1),s=this.mul(this.square(i),e);if(this.eq(s,this.negone))return null;const n=this.mul(i,e);return t.geq(n,t.zero)?n:t.neg(n)}}(t);else{const e=ot(st(t.p,t.m/2),4);1==e?function(t){t.sqrt=function(){throw new Error("Sqrt alg 10 not implemented")}}(t):3==e?function(t){t.sqrt_q=st(t.p,t.m/2),t.sqrt_e34=ht(Y(t.sqrt_q,3),4),t.sqrt_e12=ht(Y(t.sqrt_q,1),2),t.frobenius=function(e,i){return e%2==1?t.conjugate(i):i},t.sqrt=function(t){const e=this,i=e.pow(t,e.sqrt_e34),s=e.mul(e.square(i),t),n=e.mul(e.frobenius(1,s),s);if(e.eq(n,e.negone))return null;const r=e.mul(i,t);let h;if(e.eq(s,e.negone))h=e.mul(r,[e.F.zero,e.F.one]);else{const t=e.pow(e.add(e.one,s),e.sqrt_e12);h=e.mul(t,r)}return e.geq(h,e.zero)?h:e.neg(h)}}(t):function(t){t.sqrt=function(){throw new Error("Sqrt alg 8 not implemented")}}(t)}}function zt(t,e,i,s,n){t[e]=t[e]+t[i]>>>0,t[n]=(t[n]^t[e])>>>0,t[n]=(t[n]<<16|t[n]>>>16&65535)>>>0,t[s]=t[s]+t[n]>>>0,t[i]=(t[i]^t[s])>>>0,t[i]=(t[i]<<12|t[i]>>>20&4095)>>>0,t[e]=t[e]+t[i]>>>0,t[n]=(t[n]^t[e])>>>0,t[n]=(t[n]<<8|t[n]>>>24&255)>>>0,t[s]=t[s]+t[n]>>>0,t[i]=(t[i]^t[s])>>>0,t[i]=(t[i]<<7|t[i]>>>25&127)>>>0}class It{constructor(t){t=t||[0,0,0,0,0,0,0,0],this.state=[1634760805,857760878,2036477234,1797285236,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],0,0,0,0],this.idx=16,this.buff=new Array(16)}nextU32(){return 16==this.idx&&this.update(),this.buff[this.idx++]}nextU64(){return H(et(this.nextU32(),4294967296),this.nextU32())}nextBool(){return 1==(1&this.nextU32())}update(){for(let e=0;e<16;e++)this.buff[e]=this.state[e];for(let e=0;e<10;e++)zt(t=this.buff,0,4,8,12),zt(t,1,5,9,13),zt(t,2,6,10,14),zt(t,3,7,11,15),zt(t,0,5,10,15),zt(t,1,6,11,12),zt(t,2,7,8,13),zt(t,3,4,9,14);var t;for(let e=0;e<16;e++)this.buff[e]=this.buff[e]+this.state[e]>>>0;this.idx=0,this.state[12]=this.state[12]+1>>>0,0==this.state[12]&&(this.state[13]=this.state[13]+1>>>0,0==this.state[13]&&(this.state[14]=this.state[14]+1>>>0,0==this.state[14]&&(this.state[15]=this.state[15]+1>>>0)))}}function Mt(t){let e=new Uint8Array(t);if("undefined"!==typeof globalThis.crypto)globalThis.crypto.getRandomValues(e);else for(let i=0;i<t;i++)e[i]=4294967296*Math.random()>>>0;return e}let St=null;function Tt(){return St||(St=new It(function(){const t=Mt(32),e=new Uint32Array(t.buffer),i=[];for(let s=0;s<8;s++)i.push(e[s]);return i}()),St)}class Gt{constructor(t,e,i){this.F=e,this.G=t,this.opMulGF=i;let s=e.sqrt_t||e.t,n=e.sqrt_s||e.s,r=e.one;for(;e.eq(e.pow(r,e.half),e.one);)r=e.add(r,e.one);this.w=new Array(n+1),this.wi=new Array(n+1),this.w[n]=this.F.pow(r,s),this.wi[n]=this.F.inv(this.w[n]);let h=n-1;for(;h>=0;)this.w[h]=this.F.square(this.w[h+1]),this.wi[h]=this.F.square(this.wi[h+1]),h--;this.roots=[],this._setRoots(Math.min(n,15))}_setRoots(t){for(let e=t;e>=0&&!this.roots[e];e--){let t=this.F.one;const i=1<<e,s=new Array(i);for(let n=0;n<i;n++)s[n]=t,t=this.F.mul(t,this.w[e]);this.roots[e]=s}}fft(t){if(t.length<=1)return t;const e=Ut(t.length-1)+1;this._setRoots(e);const i=1<<e;if(t.length!=i)throw new Error("Size must be multiple of 2");return Nt(this,t,e,0,1)}ifft(t){if(t.length<=1)return t;const e=Ut(t.length-1)+1;this._setRoots(e);const i=1<<e;if(t.length!=i)throw new Error("Size must be multiple of 2");const s=Nt(this,t,e,0,1),n=this.F.inv(this.F.mulScalar(this.F.one,i)),r=new Array(i);for(let h=0;h<i;h++)r[h]=this.opMulGF(s[(i-h)%i],n);return r}}function Ut(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)}function Nt(t,e,i,s,n){const r=1<<i;if(1==r)return[e[s]];if(2==r)return[t.G.add(e[s],e[s+n]),t.G.sub(e[s],e[s+n])];const h=r>>1,o=Nt(t,e,i-1,s,2*n),f=Nt(t,e,i-1,s+n,2*n),u=new Array(r);for(let a=0;a<h;a++)u[a]=t.G.add(o[a],t.opMulGF(f[a],t.roots[i][a])),u[a+h]=t.G.sub(o[a],t.opMulGF(f[a],t.roots[i][a]));return u}var Ct=Object.freeze({__proto__:null,default:Gt});class jt{constructor(t){this.type="F1",this.one=BigInt(1),this.zero=BigInt(0),this.p=BigInt(t),this.m=1,this.negone=this.p-this.one,this.two=BigInt(2),this.half=this.p>>this.one,this.bitLength=j(this.p),this.mask=(this.one<<BigInt(this.bitLength))-this.one,this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=2*this.n64,this.n8=8*this.n64,this.R=this.e(this.one<<BigInt(64*this.n64)),this.Ri=this.inv(this.R);const e=this.negone>>this.one;this.nqr=this.two;let i=this.pow(this.nqr,e);for(;!this.eq(i,this.negone);)this.nqr=this.nqr+this.one,i=this.pow(this.nqr,e);for(this.s=0,this.t=this.negone;(this.t&this.one)==this.zero;)this.s=this.s+1,this.t=this.t>>this.one;this.nqr_to_t=this.pow(this.nqr,this.t),xt(this),this.FFT=new Gt(this,this,this.mul.bind(this)),this.fft=this.FFT.fft.bind(this.FFT),this.ifft=this.FFT.ifft.bind(this.FFT),this.w=this.FFT.w,this.wi=this.FFT.wi,this.shift=this.square(this.nqr),this.k=this.exp(this.nqr,2**this.s)}e(t,e){let i;if(e?16==e&&(i=BigInt("0x"+t)):i=BigInt(t),i<0){let t=-i;return t>=this.p&&(t%=this.p),this.p-t}return i>=this.p?i%this.p:i}add(t,e){const i=t+e;return i>=this.p?i-this.p:i}sub(t,e){return t>=e?t-e:this.p-e+t}neg(t){return t?this.p-t:t}mul(t,e){return t*e%this.p}mulScalar(t,e){return t*this.e(e)%this.p}square(t){return t*t%this.p}eq(t,e){return t==e}neq(t,e){return t!=e}lt(t,e){return(t>this.half?t-this.p:t)<(e>this.half?e-this.p:e)}gt(t,e){return(t>this.half?t-this.p:t)>(e>this.half?e-this.p:e)}leq(t,e){return(t>this.half?t-this.p:t)<=(e>this.half?e-this.p:e)}geq(t,e){return(t>this.half?t-this.p:t)>=(e>this.half?e-this.p:e)}div(t,e){return this.mul(t,this.inv(e))}idiv(t,e){if(!e)throw new Error("Division by zero");return t/e}inv(t){if(!t)throw new Error("Division by zero");let e=this.zero,i=this.p,s=this.one,n=t%this.p;for(;n;){let t=i/n;[e,s]=[s,e-t*s],[i,n]=[n,i-t*n]}return e<this.zero&&(e+=this.p),e}mod(t,e){return t%e}pow(t,e){return Rt(this,t,e)}exp(t,e){return Rt(this,t,e)}band(t,e){const i=t&e&this.mask;return i>=this.p?i-this.p:i}bor(t,e){const i=(t|e)&this.mask;return i>=this.p?i-this.p:i}bxor(t,e){const i=(t^e)&this.mask;return i>=this.p?i-this.p:i}bnot(t){const e=t^this.mask;return e>=this.p?e-this.p:e}shl(t,e){if(Number(e)<this.bitLength){const i=t<<e&this.mask;return i>=this.p?i-this.p:i}{const i=this.p-e;return Number(i)<this.bitLength?t>>i:this.zero}}shr(t,e){if(Number(e)<this.bitLength)return t>>e;{const i=this.p-e;if(Number(i)<this.bitLength){const e=t<<i&this.mask;return e>=this.p?e-this.p:e}return 0}}land(t,e){return t&&e?this.one:this.zero}lor(t,e){return t||e?this.one:this.zero}lnot(t){return t?this.zero:this.one}sqrt_old(t){if(t==this.zero)return this.zero;if(this.pow(t,this.negone>>this.one)!=this.one)return null;let e=this.s,i=this.nqr_to_t,s=this.pow(t,this.t),n=this.pow(t,this.add(this.t,this.one)>>this.one);for(;s!=this.one;){let t=this.square(s),r=1;for(;t!=this.one;)r++,t=this.square(t);let h=i;for(let i=0;i<e-r-1;i++)h=this.square(h);e=r,i=this.square(h),s=this.mul(s,i),n=this.mul(n,h)}return n>this.p>>this.one&&(n=this.neg(n)),n}normalize(t,e){if((t=BigInt(t,e))<0){let e=-t;return e>=this.p&&(e%=this.p),this.p-e}return t>=this.p?t%this.p:t}random(){const t=2*this.bitLength/8;let e=this.zero;for(let i=0;i<t;i++)e=(e<<BigInt(8))+BigInt(Mt(1)[0]);return e%this.p}toString(t,e){let i;if(e=e||10,t>this.half&&10==e){i="-"+(this.p-t).toString(e)}else i=t.toString(e);return i}isZero(t){return t==this.zero}fromRng(t){let e;do{e=this.zero;for(let i=0;i<this.n64;i++)e+=t.nextU64()<<BigInt(64*i);e&=this.mask}while(e>=this.p);return e=e*this.Ri%this.p,e}fft(t){return this.FFT.fft(t)}ifft(t){return this.FFT.ifft(t)}}class Zt{constructor(t){this.type="F1",this.one=u.default.one,this.zero=u.default.zero,this.p=u.default(t),this.m=1,this.negone=this.p.minus(u.default.one),this.two=u.default(2),this.half=this.p.shiftRight(1),this.bitLength=this.p.bitLength(),this.mask=u.default.one.shiftLeft(this.bitLength).minus(u.default.one),this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=2*this.n64,this.n8=8*this.n64,this.R=u.default.one.shiftLeft(64*this.n64),this.Ri=this.inv(this.R);const e=this.negone.shiftRight(this.one);this.nqr=this.two;let i=this.pow(this.nqr,e);for(;!i.equals(this.negone);)this.nqr=this.nqr.add(this.one),i=this.pow(this.nqr,e);for(this.s=this.zero,this.t=this.negone;!this.t.isOdd();)this.s=this.s.add(this.one),this.t=this.t.shiftRight(this.one);this.nqr_to_t=this.pow(this.nqr,this.t),xt(this),this.FFT=new Ct(this,this,this.mul.bind(this)),this.fft=this.FFT.fft.bind(this.FFT),this.ifft=this.FFT.ifft.bind(this.FFT),this.w=this.FFT.w,this.wi=this.FFT.wi,this.shift=this.square(this.nqr),this.k=this.exp(this.nqr,2**this.s)}e(t,e){const i=u.default(t,e);return this.normalize(i)}add(t,e){let i=t.add(e);return i.geq(this.p)&&(i=i.minus(this.p)),i}sub(t,e){return t.geq(e)?t.minus(e):this.p.minus(e.minus(t))}neg(t){return t.isZero()?t:this.p.minus(t)}mul(t,e){return t.times(e).mod(this.p)}mulScalar(t,e){return t.times(u.default(e)).mod(this.p)}square(t){return t.square().mod(this.p)}eq(t,e){return t.eq(e)}neq(t,e){return t.neq(e)}lt(t,e){const i=t.gt(this.half)?t.minus(this.p):t,s=e.gt(this.half)?e.minus(this.p):e;return i.lt(s)}gt(t,e){const i=t.gt(this.half)?t.minus(this.p):t,s=e.gt(this.half)?e.minus(this.p):e;return i.gt(s)}leq(t,e){const i=t.gt(this.half)?t.minus(this.p):t,s=e.gt(this.half)?e.minus(this.p):e;return i.leq(s)}geq(t,e){const i=t.gt(this.half)?t.minus(this.p):t,s=e.gt(this.half)?e.minus(this.p):e;return i.geq(s)}div(t,e){if(e.isZero())throw new Error("Division by zero");return t.times(e.modInv(this.p)).mod(this.p)}idiv(t,e){if(e.isZero())throw new Error("Division by zero");return t.divide(e)}inv(t){if(t.isZero())throw new Error("Division by zero");return t.modInv(this.p)}mod(t,e){return t.mod(e)}pow(t,e){return t.modPow(e,this.p)}exp(t,e){return t.modPow(e,this.p)}band(t,e){return t.and(e).and(this.mask).mod(this.p)}bor(t,e){return t.or(e).and(this.mask).mod(this.p)}bxor(t,e){return t.xor(e).and(this.mask).mod(this.p)}bnot(t){return t.xor(this.mask).mod(this.p)}shl(t,e){if(e.lt(this.bitLength))return t.shiftLeft(e).and(this.mask).mod(this.p);{const i=this.p.minus(e);return i.lt(this.bitLength)?this.shr(t,i):u.default.zero}}shr(t,e){if(e.lt(this.bitLength))return t.shiftRight(e);{const i=this.p.minus(e);return i.lt(this.bitLength)?this.shl(t,i):u.default.zero}}land(t,e){return t.isZero()||e.isZero()?u.default.zero:u.default.one}lor(t,e){return t.isZero()&&e.isZero()?u.default.zero:u.default.one}lnot(t){return t.isZero()?u.default.one:u.default.zero}sqrt_old(t){if(t.equals(this.zero))return this.zero;if(!this.pow(t,this.negone.shiftRight(this.one)).equals(this.one))return null;let e=parseInt(this.s),i=this.nqr_to_t,s=this.pow(t,this.t),n=this.pow(t,this.add(this.t,this.one).shiftRight(this.one));for(;!s.equals(this.one);){let t=this.square(s),r=1;for(;!t.equals(this.one);)r++,t=this.square(t);let h=i;for(let i=0;i<e-r-1;i++)h=this.square(h);e=r,i=this.square(h),s=this.mul(s,i),n=this.mul(n,h)}return n.greater(this.p.shiftRight(this.one))&&(n=this.neg(n)),n}normalize(t){return(t=u.default(t)).isNegative()?this.p.minus(t.abs().mod(this.p)):t.mod(this.p)}random(){let t=u.default(0),e=u.default(this.p.square());for(;!e.isZero();)t=t.shiftLeft(8).add(u.default(Mt(1)[0])),e=e.shiftRight(8);return t.mod(this.p)}toString(t,e){let i;if(e=e||10,t.lesserOrEquals(this.p.shiftRight(u.default(1)))||10!=e)i=t.toString(e);else{i="-"+this.p.minus(t).toString(e)}return i}isZero(t){return t.isZero()}fromRng(t){let e;do{e=u.default(0);for(let i=0;i<this.n64;i++)e=e.add(e,t.nextU64().shiftLeft(64*i));e=e.and(this.mask)}while(e.geq(this.p));return e=e.times(this.Ri).mod(this.q),e}fft(t){return this.FFT.fft(t)}ifft(t){return this.FFT.ifft(t)}}const kt="function"===typeof BigInt;let $t;$t=kt?jt:Zt;class Pt extends $t{toRprLE(t,e,i){R(t,e,i,8*this.n64)}toRprBE(t,e,i){x(t,e,i,8*this.n64)}toRprBEM(t,e,i){return this.toRprBE(t,e,this.mul(this.R,i))}toRprLEM(t,e,i){return this.toRprLE(t,e,this.mul(this.R,i))}fromRprLE(t,e){return z(t,e,this.n8)}fromRprBE(t,e){return I(t,e,this.n8)}fromRprLEM(t,e){return this.mul(this.fromRprLE(t,e),this.Ri)}fromRprBEM(t,e){return this.mul(this.fromRprBE(t,e),this.Ri)}toObject(t){return t}}function Jt(t,e){if(Array.isArray(e)){for(let i=e.length-1;i>=0;i--)if(!t.F.isZero(e[i]))return Jt(t.F,e[i]);return 0}{const i=t.neg(e);return lt(e,i)}}var Dt=Object.freeze({__proto__:null,stringifyBigInts:function t(e){if("bigint"==typeof e||void 0!==e.eq)return e.toString(10);if(e instanceof Uint8Array)return z(e,0);if(Array.isArray(e))return e.map(t);if("object"==typeof e){const i={};return Object.keys(e).forEach((s=>{i[s]=t(e[s])})),i}return e},unstringifyBigInts:function t(e){if("string"==typeof e&&/^[0-9]+$/.test(e))return BigInt(e);if("string"==typeof e&&/^0x[0-9a-fA-F]+$/.test(e))return BigInt(e);if(Array.isArray(e))return e.map(t);if("object"==typeof e){if(null===e)return null;const i={};return Object.keys(e).forEach((s=>{i[s]=t(e[s])})),i}return e},beBuff2int:function(t){let e=BigInt(0),i=t.length,s=0;const n=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;i>0;)i>=4?(i-=4,e+=BigInt(n.getUint32(i))<<BigInt(8*s),s+=4):i>=2?(i-=2,e+=BigInt(n.getUint16(i))<<BigInt(8*s),s+=2):(i-=1,e+=BigInt(n.getUint8(i))<<BigInt(8*s),s+=1);return e},beInt2Buff:function(t,e){let i=t;const s=new Uint8Array(e),n=new DataView(s.buffer);let r=e;for(;r>0;)r-4>=0?(r-=4,n.setUint32(r,Number(i&BigInt(4294967295))),i>>=BigInt(32)):r-2>=0?(r-=2,n.setUint16(r,Number(i&BigInt(65535))),i>>=BigInt(16)):(r-=1,n.setUint8(r,Number(i&BigInt(255))),i>>=BigInt(8));if(i)throw new Error("Number does not fit in this length");return s},leBuff2int:function(t){let e=BigInt(0),i=0;const s=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;i<t.length;)i+4<=t.length?(e+=BigInt(s.getUint32(i,!0))<<BigInt(8*i),i+=4):i+4<=t.length?(e+=BigInt(s.getUint16(i,!0))<<BigInt(8*i),i+=2):(e+=BigInt(s.getUint8(i,!0))<<BigInt(8*i),i+=1);return e},leInt2Buff:function(t,e){let i=t;"undefined"===typeof e&&0==(e=Math.floor((j(t)-1)/8)+1)&&(e=1);const s=new Uint8Array(e),n=new DataView(s.buffer);let r=0;for(;r<e;)r+4<=e?(n.setUint32(r,Number(i&BigInt(4294967295)),!0),r+=4,i>>=BigInt(32)):r+2<=e?(n.setUint16(Number(r,i&BigInt(65535)),!0),r+=2,i>>=BigInt(16)):(n.setUint8(Number(r,i&BigInt(255)),!0),r+=1,i>>=BigInt(8));if(i)throw new Error("Number does not fit in this length");return s},stringifyFElements:function t(e,i){if("bigint"==typeof i||void 0!==i.eq)return i.toString(10);if(i instanceof Uint8Array)return e.toString(e.e(i));if(Array.isArray(i))return i.map(t.bind(this,e));if("object"==typeof i){const s={};return Object.keys(i).forEach((n=>{s[n]=t(e,i[n])})),s}return i},unstringifyFElements:function t(e,i){if("string"==typeof i&&/^[0-9]+$/.test(i))return e.e(i);if("string"==typeof i&&/^0x[0-9a-fA-F]+$/.test(i))return e.e(i);if(Array.isArray(i))return i.map(t.bind(this,e));if("object"==typeof i){if(null===i)return null;const s={};return Object.keys(i).forEach((n=>{s[n]=t(e,i[n])})),s}return i}});var Qt=Object.freeze({__proto__:null,stringifyBigInts:function t(e){if("bigint"==typeof e||void 0!==e.eq)return e.toString(10);if(Array.isArray(e))return e.map(t);if("object"==typeof e){const i={};return Object.keys(e).forEach((s=>{i[s]=t(e[s])})),i}return e},unstringifyBigInts:function t(e){if("string"==typeof e&&/^[0-9]+$/.test(e))return u.default(e);if("string"==typeof e&&/^0x[0-9a-fA-F]+$/.test(e))return u.default(e);if(Array.isArray(e))return e.map(t);if("object"==typeof e){const i={};return Object.keys(e).forEach((s=>{i[s]=t(e[s])})),i}return e},beBuff2int:function(t){let e=u.default.zero;for(let i=0;i<t.length;i++){const s=u.default(t[t.length-i-1]);e=e.add(s.shiftLeft(8*i))}return e},beInt2Buff:function(t,e){let i=t,s=e-1;const n=new Uint8Array(e);for(;i.gt(u.default.zero)&&s>=0;){let t=Number(i.and(u.default("255")));n[s]=t,s--,i=i.shiftRight(8)}if(!i.eq(u.default.zero))throw new Error("Number does not fit in this length");return n},leBuff2int:function(t){let e=u.default.zero;for(let i=0;i<t.length;i++){const s=u.default(t[i]);e=e.add(s.shiftLeft(8*i))}return e},leInt2Buff:function(t,e){let i=t,s=0;const n=new Uint8Array(e);for(;i.gt(u.default.zero)&&s<n.length;){let t=Number(i.and(u.default(255)));n[s]=t,s++,i=i.shiftRight(8)}if(!i.eq(u.default.zero))throw new Error("Number does not fit in this length");return n}});let Xt={};"function"===typeof BigInt?Object.assign(Xt,Dt):Object.assign(Xt,Qt);const Vt=[];for(let Ge=0;Ge<256;Ge++)Vt[Ge]=Wt(Ge,8);function Wt(t,e){let i=0,s=t;for(let n=0;n<e;n++)i<<=1,i|=1&s,s>>=1;return i}Xt.bitReverse=function(t,e){return(Vt[t>>>24]|Vt[t>>>16&255]<<8|Vt[t>>>8&255]<<16|Vt[255&t]<<24)>>>32-e},Xt.log2=function(t){return(0!==(4294901760&t)?(t&=4294901760,16):0)|(0!==(4278255360&t)?(t&=4278255360,8):0)|(0!==(4042322160&t)?(t&=4042322160,4):0)|(0!==(3435973836&t)?(t&=3435973836,2):0)|0!==(2863311530&t)},Xt.buffReverseBits=function(t,e){const i=t.byteLength/e,s=Xt.log2(i);if(i!=1<<s)throw new Error("Invalid number of pointers");for(let n=0;n<i;n++){const i=Xt.bitReverse(n,s);if(n>i){const s=t.slice(n*e,(n+1)*e);t.set(t.slice(i*e,(i+1)*e),n*e),t.set(s,i*e)}}},Xt.array2buffer=function(t,e){const i=new Uint8Array(e*t.length);for(let s=0;s<t.length;s++)i.set(t[s],s*e);return i},Xt.buffer2array=function(t,e){const i=t.byteLength/e,s=new Array(i);for(let n=0;n<i;n++)s[n]=t.slice(n*e,n*e+e);return s};let{bitReverse:Kt,log2:Ht,buffReverseBits:Yt,stringifyBigInts:te,unstringifyBigInts:ee,beBuff2int:ie,beInt2Buff:se,leBuff2int:ne,leInt2Buff:re,array2buffer:he,buffer2array:oe,stringifyFElements:fe,unstringifyFElements:ue}=Xt;var ae=Object.freeze({__proto__:null,bitReverse:Kt,log2:Ht,buffReverseBits:Yt,stringifyBigInts:te,unstringifyBigInts:ee,beBuff2int:ie,beInt2Buff:se,leBuff2int:ne,leInt2Buff:re,array2buffer:he,buffer2array:oe,stringifyFElements:fe,unstringifyFElements:ue});const le=1<<30;class pe{constructor(t){this.buffers=[],this.byteLength=t;for(let e=0;e<t;e+=le){const i=Math.min(t-e,le);this.buffers.push(new Uint8Array(i))}}slice(t,e){void 0===e&&(e=this.byteLength),void 0===t&&(t=0);const i=e-t,s=Math.floor(t/le);if(s==Math.floor((t+i-1)/le)||0==i)return this.buffers[s].slice(t%le,t%le+i);let n,r=s,h=t%le,o=i;for(;o>0;){const t=h+o>le?le-h:o,e=new Uint8Array(this.buffers[r].buffer,this.buffers[r].byteOffset+h,t);if(t==i)return e.slice();n||(n=i<=le?new Uint8Array(i):new pe(i)),n.set(e,i-o),o-=t,r++,h=0}return n}set(t,e){void 0===e&&(e=0);const i=t.byteLength;if(0==i)return;const s=Math.floor(e/le);if(s==Math.floor((e+i-1)/le))return t instanceof pe&&1==t.buffers.length?this.buffers[s].set(t.buffers[0],e%le):this.buffers[s].set(t,e%le);let n=s,r=e%le,h=i;for(;h>0;){const e=r+h>le?le-r:h,s=t.slice(i-h,i-h+e);new Uint8Array(this.buffers[n].buffer,this.buffers[n].byteOffset+r,e).set(s),h-=e,n++,r=0}}}function ce(t,e,i,s){return async function(n){const r=Math.floor(n.byteLength/i);if(r*i!==n.byteLength)throw new Error("Invalid buffer size");const h=Math.floor(r/t.concurrency),o=[];for(let l=0;l<t.concurrency;l++){let f;if(f=l<t.concurrency-1?h:r-l*h,0==f)continue;const u=[{cmd:"ALLOCSET",var:0,buff:n.slice(l*h*i,l*h*i+f*i)},{cmd:"ALLOC",var:1,len:s*f},{cmd:"CALL",fnName:e,params:[{var:0},{val:f},{var:1}]},{cmd:"GET",out:0,var:1,len:s*f}];o.push(t.queueAction(u))}const f=await Promise.all(o);let u;u=n instanceof pe?new pe(r*s):new Uint8Array(r*s);let a=0;for(let t=0;t<f.length;t++)u.set(f[t][0],a),a+=f[t][0].byteLength;return u}}class me{constructor(t,e,i,s){if(this.tm=t,this.prefix=e,this.p=s,this.n8=i,this.type="F1",this.m=1,this.half=P(s,G),this.bitLength=j(s),this.mask=Y($(G,this.bitLength),G),this.pOp1=t.alloc(i),this.pOp2=t.alloc(i),this.pOp3=t.alloc(i),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,this.n8),this.tm.instance.exports[e+"_one"](this.pOp1),this.one=this.tm.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.n64=Math.floor(i/8),this.n32=Math.floor(i/4),8*this.n64!=this.n8)throw new Error("n8 must be a multiple of 8");this.half=P(this.p,G),this.nqr=this.two;let n=this.exp(this.nqr,this.half);for(;!this.eq(n,this.negone);)this.nqr=this.add(this.nqr,this.one),n=this.exp(this.nqr,this.half);this.shift=this.mul(this.nqr,this.nqr),this.shiftInv=this.inv(this.shift),this.s=0;let r=Y(this.p,G);for(;!Q(r);)this.s=this.s+1,r=P(r,G);this.w=[],this.w[this.s]=this.exp(this.nqr,r);for(let h=this.s-1;h>=0;h--)this.w[h]=this.square(this.w[h+1]);if(!this.eq(this.w[0],this.one))throw new Error("Error calculating roots of unity");this.batchToMontgomery=ce(t,e+"_batchToMontgomery",this.n8,this.n8),this.batchFromMontgomery=ce(t,e+"_batchFromMontgomery",this.n8,this.n8)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,e){return this.op2("_add",t,e)}eq(t,e){return this.op2Bool("_eq",t,e)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,e){return this.op2("_sub",t,e)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,e){return this.op2("_mul",t,e)}div(t,e){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,e){return e instanceof Uint8Array||(e=S(N(e))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}isNegative(t){return this.op1Bool("_isNegative",t)}e(t,e){if(t instanceof Uint8Array)return t;let i=N(t,e);Z(i)?(i=tt(i),lt(i,this.p)&&(i=ot(i,this.p)),i=Y(this.p,i)):lt(i,this.p)&&(i=ot(i,this.p));const s=re(i,this.n8);return this.toMontgomery(s)}toString(t,e){const i=this.fromMontgomery(t),s=z(i,0);return M(s,e)}fromRng(t){let e;const i=new Uint8Array(this.n8);do{e=T;for(let i=0;i<this.n64;i++)e=H(e,$(t.nextU64(),64*i));e=mt(e,this.mask)}while(ct(e,this.p));return R(i,0,e,this.n8),i}random(){return this.fromRng(Tt())}toObject(t){const e=this.fromMontgomery(t);return z(e,0)}fromObject(t){const e=new Uint8Array(this.n8);return R(e,0,t,this.n8),this.toMontgomery(e)}toRprLE(t,e,i){t.set(this.fromMontgomery(i),e)}toRprBE(t,e,i){const s=this.fromMontgomery(i);for(let n=0;n<this.n8/2;n++){const t=s[n];s[n]=s[this.n8-1-n],s[this.n8-1-n]=t}t.set(s,e)}fromRprLE(t,e){e=e||0;const i=t.slice(e,e+this.n8);return this.toMontgomery(i)}async batchInverse(t){let e=!1;const i=this.n8,s=this.n8;Array.isArray(t)?(t=he(t,i),e=!0):t=t.slice(0,t.byteLength);const n=Math.floor(t.byteLength/i);if(n*i!==t.byteLength)throw new Error("Invalid buffer size");const r=Math.floor(n/this.tm.concurrency),h=[];for(let a=0;a<this.tm.concurrency;a++){let e;if(e=a<this.tm.concurrency-1?r:n-a*r,0==e)continue;const o=[{cmd:"ALLOCSET",var:0,buff:t.slice(a*r*i,a*r*i+e*i)},{cmd:"ALLOC",var:1,len:s*e},{cmd:"CALL",fnName:this.prefix+"_batchInverse",params:[{var:0},{val:i},{val:e},{var:1},{val:s}]},{cmd:"GET",out:0,var:1,len:s*e}];h.push(this.tm.queueAction(o))}const o=await Promise.all(h);let f;f=t instanceof pe?new pe(n*s):new Uint8Array(n*s);let u=0;for(let a=0;a<o.length;a++)f.set(o[a][0],u),u+=o[a][0].byteLength;return e?oe(f,s):f}}class ge{constructor(t,e,i){this.tm=t,this.prefix=e,this.F=i,this.type="F2",this.m=2*i.m,this.n8=2*this.F.n8,this.n32=2*this.F.n32,this.n64=2*this.F.n64,this.pOp1=t.alloc(2*i.n8),this.pOp2=t.alloc(2*i.n8),this.pOp3=t.alloc(2*i.n8),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[e+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,e){return this.op2("_add",t,e)}eq(t,e){return this.op2Bool("_eq",t,e)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,e){return this.op2("_sub",t,e)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,e){return this.op2("_mul",t,e)}mul1(t,e){return this.op2("_mul1",t,e)}div(t,e){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,e){return e instanceof Uint8Array||(e=S(N(e))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}e(t,e){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&2==t.length){const i=this.F.e(t[0],e),s=this.F.e(t[1],e),n=new Uint8Array(2*this.F.n8);return n.set(i),n.set(s,2*this.F.n8),n}throw new Error("invalid F2")}toString(t,e){return`[${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8),e)}]`}fromRng(t){const e=this.F.fromRng(t),i=this.F.fromRng(t),s=new Uint8Array(2*this.F.n8);return s.set(e),s.set(i,this.F.n8),s}random(){return this.fromRng(Tt())}toObject(t){return[this.F.toObject(t.slice(0,this.F.n8)),this.F.toObject(t.slice(this.F.n8,2*this.F.n8))]}fromObject(t){const e=new Uint8Array(2*this.F.n8),i=this.F.fromObject(t[0]),s=this.F.fromObject(t[1]);return e.set(i),e.set(s,this.F.n8),e}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8)}}class de{constructor(t,e,i){this.tm=t,this.prefix=e,this.F=i,this.type="F3",this.m=3*i.m,this.n8=3*this.F.n8,this.n32=3*this.F.n32,this.n64=3*this.F.n64,this.pOp1=t.alloc(3*i.n8),this.pOp2=t.alloc(3*i.n8),this.pOp3=t.alloc(3*i.n8),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[e+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}eq(t,e){return this.op2Bool("_eq",t,e)}isZero(t){return this.op1Bool("_isZero",t)}add(t,e){return this.op2("_add",t,e)}sub(t,e){return this.op2("_sub",t,e)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,e){return this.op2("_mul",t,e)}div(t,e){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,e){return e instanceof Uint8Array||(e=S(N(e))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.getBuff(this.pOp3,this.n8)}e(t,e){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&3==t.length){const i=this.F.e(t[0],e),s=this.F.e(t[1],e),n=this.F.e(t[2],e),r=new Uint8Array(3*this.F.n8);return r.set(i),r.set(s,this.F.n8),r.set(n,2*this.F.n8),r}throw new Error("invalid F3")}toString(t,e){return`[${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8,2*this.F.n8),e)}, ${this.F.toString(t.slice(2*this.F.n8),e)}]`}fromRng(t){const e=this.F.fromRng(t),i=this.F.fromRng(t),s=this.F.fromRng(t),n=new Uint8Array(3*this.F.n8);return n.set(e),n.set(i,this.F.n8),n.set(s,2*this.F.n8),n}random(){return this.fromRng(Tt())}toObject(t){return[this.F.toObject(t.slice(0,this.F.n8)),this.F.toObject(t.slice(this.F.n8,2*this.F.n8)),this.F.toObject(t.slice(2*this.F.n8,3*this.F.n8))]}fromObject(t){const e=new Uint8Array(3*this.F.n8),i=this.F.fromObject(t[0]),s=this.F.fromObject(t[1]),n=this.F.fromObject(t[2]);return e.set(i),e.set(s,this.F.n8),e.set(n,2*this.F.n8),e}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8,2*this.F.n8)}c3(t){return t.slice(2*this.F.n8)}}class Fe{constructor(t,e,i,s,n,r){this.tm=t,this.prefix=e,this.F=i,this.pOp1=t.alloc(3*i.n8),this.pOp2=t.alloc(3*i.n8),this.pOp3=t.alloc(3*i.n8),this.tm.instance.exports[e+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,3*i.n8),this.tm.instance.exports[e+"_zeroAffine"](this.pOp1),this.zeroAffine=this.tm.getBuff(this.pOp1,2*i.n8),this.one=this.tm.getBuff(s,3*i.n8),this.g=this.one,this.oneAffine=this.tm.getBuff(s,2*i.n8),this.gAffine=this.oneAffine,this.b=this.tm.getBuff(n,i.n8),r&&(this.cofactor=S(r)),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.batchLEMtoC=ce(t,e+"_batchLEMtoC",2*i.n8,i.n8),this.batchLEMtoU=ce(t,e+"_batchLEMtoU",2*i.n8,2*i.n8),this.batchCtoLEM=ce(t,e+"_batchCtoLEM",i.n8,2*i.n8),this.batchUtoLEM=ce(t,e+"_batchUtoLEM",2*i.n8,2*i.n8),this.batchToJacobian=ce(t,e+"_batchToJacobian",2*i.n8,3*i.n8),this.batchToAffine=ce(t,e+"_batchToAffine",3*i.n8,2*i.n8)}op2(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}op2bool(t,e,i){return this.tm.setBuff(this.pOp1,e),this.tm.setBuff(this.pOp2,i),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3)}op1(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}op1Affine(t,e){return this.tm.setBuff(this.pOp1,e),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,2*this.F.n8)}op1Bool(t,e){return this.tm.setBuff(this.pOp1,e),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,e){if(t.byteLength==3*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_add",t,e);if(e.byteLength==2*this.F.n8)return this.op2("_addMixed",t,e);throw new Error("invalid point size")}if(t.byteLength==2*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_addMixed",e,t);if(e.byteLength==2*this.F.n8)return this.op2("_addAffine",t,e);throw new Error("invalid point size")}throw new Error("invalid point size")}sub(t,e){if(t.byteLength==3*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_sub",t,e);if(e.byteLength==2*this.F.n8)return this.op2("_subMixed",t,e);throw new Error("invalid point size")}if(t.byteLength==2*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2("_subMixed",e,t);if(e.byteLength==2*this.F.n8)return this.op2("_subAffine",t,e);throw new Error("invalid point size")}throw new Error("invalid point size")}neg(t){if(t.byteLength==3*this.F.n8)return this.op1("_neg",t);if(t.byteLength==2*this.F.n8)return this.op1Affine("_negAffine",t);throw new Error("invalid point size")}double(t){if(t.byteLength==3*this.F.n8)return this.op1("_double",t);if(t.byteLength==2*this.F.n8)return this.op1("_doubleAffine",t);throw new Error("invalid point size")}isZero(t){if(t.byteLength==3*this.F.n8)return this.op1Bool("_isZero",t);if(t.byteLength==2*this.F.n8)return this.op1Bool("_isZeroAffine",t);throw new Error("invalid point size")}timesScalar(t,e){let i;if(e instanceof Uint8Array||(e=S(N(e))),t.byteLength==3*this.F.n8)i=this.prefix+"_timesScalar";else{if(t.byteLength!=2*this.F.n8)throw new Error("invalid point size");i=this.prefix+"_timesScalarAffine"}return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[i](this.pOp1,this.pOp2,e.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}timesFr(t,e){let i;if(t.byteLength==3*this.F.n8)i=this.prefix+"_timesFr";else{if(t.byteLength!=2*this.F.n8)throw new Error("invalid point size");i=this.prefix+"_timesFrAffine"}return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,e),this.tm.instance.exports[i](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}eq(t,e){if(t.byteLength==3*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2bool("_eq",t,e);if(e.byteLength==2*this.F.n8)return this.op2bool("_eqMixed",t,e);throw new Error("invalid point size")}if(t.byteLength==2*this.F.n8){if(e.byteLength==3*this.F.n8)return this.op2bool("_eqMixed",e,t);if(e.byteLength==2*this.F.n8)return this.op2bool("_eqAffine",t,e);throw new Error("invalid point size")}throw new Error("invalid point size")}toAffine(t){if(t.byteLength==3*this.F.n8)return this.op1Affine("_toAffine",t);if(t.byteLength==2*this.F.n8)return t;throw new Error("invalid point size")}toJacobian(t){if(t.byteLength==3*this.F.n8)return t;if(t.byteLength==2*this.F.n8)return this.op1("_toJacobian",t);throw new Error("invalid point size")}toRprUncompressed(t,e,i){if(this.tm.setBuff(this.pOp1,i),i.byteLength==3*this.F.n8)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(i.byteLength!=2*this.F.n8)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoU"](this.pOp1,this.pOp1);const s=this.tm.getBuff(this.pOp1,2*this.F.n8);t.set(s,e)}fromRprUncompressed(t,e){const i=t.slice(e,e+2*this.F.n8);return this.tm.setBuff(this.pOp1,i),this.tm.instance.exports[this.prefix+"_UtoLEM"](this.pOp1,this.pOp1),this.tm.getBuff(this.pOp1,2*this.F.n8)}toRprCompressed(t,e,i){if(this.tm.setBuff(this.pOp1,i),i.byteLength==3*this.F.n8)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(i.byteLength!=2*this.F.n8)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoC"](this.pOp1,this.pOp1);const s=this.tm.getBuff(this.pOp1,this.F.n8);t.set(s,e)}fromRprCompressed(t,e){const i=t.slice(e,e+this.F.n8);return this.tm.setBuff(this.pOp1,i),this.tm.instance.exports[this.prefix+"_CtoLEM"](this.pOp1,this.pOp2),this.tm.getBuff(this.pOp2,2*this.F.n8)}toUncompressed(t){const e=new Uint8Array(2*this.F.n8);return this.toRprUncompressed(e,0,t),e}toRprLEM(t,e,i){if(i.byteLength!=2*this.F.n8){if(i.byteLength!=3*this.F.n8)throw new Error("invalid point size");{this.tm.setBuff(this.pOp1,i),this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);const s=this.tm.getBuff(this.pOp1,2*this.F.n8);t.set(s,e)}}else t.set(i,e)}fromRprLEM(t,e){return e=e||0,t.slice(e,e+2*this.F.n8)}toString(t,e){if(t.byteLength==3*this.F.n8){return`[ ${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8,2*this.F.n8),e)}, ${this.F.toString(t.slice(2*this.F.n8),e)} ]`}if(t.byteLength==2*this.F.n8){return`[ ${this.F.toString(t.slice(0,this.F.n8),e)}, ${this.F.toString(t.slice(this.F.n8),e)} ]`}throw new Error("invalid point size")}isValid(t){if(this.isZero(t))return!0;const e=this.F,i=this.toAffine(t),s=i.slice(0,this.F.n8),n=i.slice(this.F.n8,2*this.F.n8),r=e.add(e.mul(e.square(s),s),this.b),h=e.square(n);return e.eq(r,h)}fromRng(t){const e=this.F;let i,s,n=[];do{n[0]=e.fromRng(t),i=t.nextBool(),s=e.add(e.mul(e.square(n[0]),n[0]),this.b)}while(!e.isSquare(s));n[1]=e.sqrt(s);i^e.isNegative(n[1])&&(n[1]=e.neg(n[1]));let r=new Uint8Array(2*this.F.n8);return r.set(n[0]),r.set(n[1],this.F.n8),this.cofactor&&(r=this.timesScalar(r,this.cofactor)),r}toObject(t){if(this.isZero(t))return[this.F.toObject(this.F.zero),this.F.toObject(this.F.one),this.F.toObject(this.F.zero)];const e=this.F.toObject(t.slice(0,this.F.n8)),i=this.F.toObject(t.slice(this.F.n8,2*this.F.n8));let s;return s=t.byteLength==3*this.F.n8?this.F.toObject(t.slice(2*this.F.n8,3*this.F.n8)):this.F.toObject(this.F.one),[e,i,s]}fromObject(t){const e=this.F.fromObject(t[0]),i=this.F.fromObject(t[1]);let s;if(s=3==t.length?this.F.fromObject(t[2]):this.F.one,this.F.isZero(s,this.F.one))return this.zeroAffine;if(this.F.eq(s,this.F.one)){const t=new Uint8Array(2*this.F.n8);return t.set(e),t.set(i,this.F.n8),t}{const t=new Uint8Array(3*this.F.n8);return t.set(e),t.set(i,this.F.n8),t.set(s,2*this.F.n8),t}}e(t){return t instanceof Uint8Array?t:this.fromObject(t)}x(t){return this.toAffine(t).slice(0,this.F.n8)}y(t){return this.toAffine(t).slice(this.F.n8)}}function be(t){const e=32767;let i,s;async function n(t){const n=new Uint8Array(t.code),r=await WebAssembly.compile(n);s=new WebAssembly.Memory({initial:t.init,maximum:e}),i=await WebAssembly.instantiate(r,{env:{memory:s}})}function r(t){const i=new Uint32Array(s.buffer,0,1);for(;3&i[0];)i[0]++;const n=i[0];if(i[0]+=t,i[0]+t>s.buffer.byteLength){const n=s.buffer.byteLength/65536;let r=Math.floor((i[0]+t)/65536)+1;r>e&&(r=e),s.grow(r-n)}return n}function h(t){const e=r(t.byteLength);return f(e,t),e}function o(t,e){const i=new Uint8Array(s.buffer);return new Uint8Array(i.buffer,i.byteOffset+t,e)}function f(t,e){new Uint8Array(s.buffer).set(new Uint8Array(e),t)}function u(t){if("INIT"==t[0].cmd)return n(t[0]);const e={vars:[],out:[]},u=new Uint32Array(s.buffer,0,1)[0];for(let s=0;s<t.length;s++)switch(t[s].cmd){case"ALLOCSET":e.vars[t[s].var]=h(t[s].buff);break;case"ALLOC":e.vars[t[s].var]=r(t[s].len);break;case"SET":f(e.vars[t[s].var],t[s].buff);break;case"CALL":{const n=[];for(let i=0;i<t[s].params.length;i++){const r=t[s].params[i];"undefined"!==typeof r.var?n.push(e.vars[r.var]+(r.offset||0)):"undefined"!=typeof r.val&&n.push(r.val)}i.exports[t[s].fnName](...n);break}case"GET":e.out[t[s].out]=o(e.vars[t[s].var],t[s].len).slice();break;default:throw new Error("Invalid cmd")}return new Uint32Array(s.buffer,0,1)[0]=u,e.out}return t&&(t.onmessage=function(e){let i;if(i=e.data?e.data:e,"INIT"==i[0].cmd)n(i[0]).then((function(){t.postMessage(i.result)}));else if("TERMINATE"==i[0].cmd)t.close();else{const e=u(i);t.postMessage(e)}}),u}class ye{constructor(){this.promise=new Promise(((t,e)=>{this.reject=e,this.resolve=t}))}}var we;const Le="data:application/javascript;base64,"+(we="("+be.toString()+")(self)",globalThis.btoa(we));class ve{constructor(){this.actionQueue=[],this.oldPFree=0}startSyncOp(){if(0!=this.oldPFree)throw new Error("Sync operation in progress");this.oldPFree=this.u32[0]}endSyncOp(){if(0==this.oldPFree)throw new Error("No sync operation in progress");this.u32[0]=this.oldPFree,this.oldPFree=0}postAction(t,e,i,s){if(this.working[t])throw new Error("Posting a job t a working worker");return this.working[t]=!0,this.pendingDeferreds[t]=s||new ye,this.workers[t].postMessage(e,i),this.pendingDeferreds[t].promise}processWorks(){for(let t=0;t<this.workers.length&&this.actionQueue.length>0;t++)if(0==this.working[t]){const e=this.actionQueue.shift();this.postAction(t,e.data,e.transfers,e.deferred)}}queueAction(t,e){const i=new ye;if(this.singleThread){const e=this.taskManager(t);i.resolve(e)}else this.actionQueue.push({data:t,transfers:e,deferred:i}),this.processWorks();return i.promise}resetMemory(){this.u32[0]=this.initalPFree}allocBuff(t){const e=this.alloc(t.byteLength);return this.setBuff(e,t),e}getBuff(t,e){return this.u8.slice(t,t+e)}setBuff(t,e){this.u8.set(new Uint8Array(e),t)}alloc(t){for(;3&this.u32[0];)this.u32[0]++;const e=this.u32[0];return this.u32[0]+=t,e}async terminate(){for(let e=0;e<this.workers.length;e++)this.workers[e].postMessage([{cmd:"TERMINATE"}]);var t;await(t=200,new Promise((e=>setTimeout(e,t))))}}function Be(t,e){const i=t[e],s=t.Fr,n=t.tm;t[e].batchApplyKey=async function(t,r,h,o,f){let u,a,l,p,c;if(o=o||"affine",f=f||"affine","G1"==e)"jacobian"==o?(l=3*i.F.n8,u="g1m_batchApplyKey"):(l=2*i.F.n8,u="g1m_batchApplyKeyMixed"),p=3*i.F.n8,"jacobian"==f?c=3*i.F.n8:(a="g1m_batchToAffine",c=2*i.F.n8);else if("G2"==e)"jacobian"==o?(l=3*i.F.n8,u="g2m_batchApplyKey"):(l=2*i.F.n8,u="g2m_batchApplyKeyMixed"),p=3*i.F.n8,"jacobian"==f?c=3*i.F.n8:(a="g2m_batchToAffine",c=2*i.F.n8);else{if("Fr"!=e)throw new Error("Invalid group: "+e);u="frm_batchApplyKey",l=i.n8,p=i.n8,c=i.n8}const m=Math.floor(t.byteLength/l),g=Math.floor(m/n.concurrency),d=[];h=s.e(h);let F=s.e(r);for(let e=0;e<n.concurrency;e++){let i;if(i=e<n.concurrency-1?g:m-e*g,0==i)continue;const r=[];r.push({cmd:"ALLOCSET",var:0,buff:t.slice(e*g*l,e*g*l+i*l)}),r.push({cmd:"ALLOCSET",var:1,buff:F}),r.push({cmd:"ALLOCSET",var:2,buff:h}),r.push({cmd:"ALLOC",var:3,len:i*Math.max(p,c)}),r.push({cmd:"CALL",fnName:u,params:[{var:0},{val:i},{var:1},{var:2},{var:3}]}),a&&r.push({cmd:"CALL",fnName:a,params:[{var:3},{val:i},{var:3}]}),r.push({cmd:"GET",out:0,var:3,len:i*c}),d.push(n.queueAction(r)),F=s.mul(F,s.exp(h,i))}const b=await Promise.all(d);let y;y=t instanceof pe?new pe(m*c):new Uint8Array(m*c);let w=0;for(let e=0;e<b.length;e++)y.set(b[e][0],w),w+=b[e][0].byteLength;return y}}const qe=[1,1,1,1,2,3,4,5,6,7,7,8,9,10,11,12,13,13,14,15,16,16,17,17,17,17,17,17,17,17,17,17];function Ee(t,e){const i=t[e],s=i.tm;async function n(t,s,n,r,h){if(!(t instanceof Uint8Array))throw r&&r.error(`${h} _multiExpChunk buffBases is not Uint8Array`),new Error(`${h} _multiExpChunk buffBases is not Uint8Array`);if(!(s instanceof Uint8Array))throw r&&r.error(`${h} _multiExpChunk buffScalars is not Uint8Array`),new Error(`${h} _multiExpChunk buffScalars is not Uint8Array`);let o,f;if(n=n||"affine","G1"==e)"affine"==n?(f="g1m_multiexpAffine_chunk",o=2*i.F.n8):(f="g1m_multiexp_chunk",o=3*i.F.n8);else{if("G2"!=e)throw new Error("Invalid group");"affine"==n?(f="g2m_multiexpAffine_chunk",o=2*i.F.n8):(f="g2m_multiexp_chunk",o=3*i.F.n8)}const u=Math.floor(t.byteLength/o);if(0==u)return i.zero;const a=Math.floor(s.byteLength/u);if(a*u!=s.byteLength)throw new Error("Scalar size does not match");const l=qe[Ht(u)],p=Math.floor((8*a-1)/l)+1,c=[];for(let e=0;e<p;e++){const n=[{cmd:"ALLOCSET",var:0,buff:t},{cmd:"ALLOCSET",var:1,buff:s},{cmd:"ALLOC",var:2,len:3*i.F.n8},{cmd:"CALL",fnName:f,params:[{var:0},{var:1},{val:a},{val:u},{val:e*l},{val:Math.min(8*a-e*l,l)},{var:2}]},{cmd:"GET",out:0,var:2,len:3*i.F.n8}];c.push(i.tm.queueAction(n))}const m=await Promise.all(c);let g=i.zero;for(let e=m.length-1;e>=0;e--){if(!i.isZero(g))for(let t=0;t<l;t++)g=i.double(g);g=i.add(g,m[e][0])}return g}async function r(t,r,h,o,f){const u=1<<22;let a;if("G1"==e)a="affine"==h?2*i.F.n8:3*i.F.n8;else{if("G2"!=e)throw new Error("Invalid group");a="affine"==h?2*i.F.n8:3*i.F.n8}const l=Math.floor(t.byteLength/a),p=Math.floor(r.byteLength/l);if(p*l!=r.byteLength)throw new Error("Scalar size does not match");const c=qe[Ht(l)],m=Math.floor((8*p-1)/c)+1;let g;g=Math.floor(l/(s.concurrency/m)),g>u&&(g=u),g<1024&&(g=1024);const d=[];for(let e=0;e<l;e+=g){o&&o.debug(`Multiexp start: ${f}: ${e}/${l}`);const i=Math.min(l-e,g),s=t.slice(e*a,(e+i)*a),u=r.slice(e*p,(e+i)*p);d.push(n(s,u,h,o,f).then((t=>(o&&o.debug(`Multiexp end: ${f}: ${e}/${l}`),t))))}const F=await Promise.all(d);let b=i.zero;for(let e=F.length-1;e>=0;e--)b=i.add(b,F[e]);return b}i.multiExp=async function(t,e,i,s){return await r(t,e,"jacobian",i,s)},i.multiExpAffine=async function(t,e,i,s){return await r(t,e,"affine",i,s)}}function Oe(t,e){const i=t[e],s=t.Fr,n=i.tm;async function r(t,o,f,u,a,l){f=f||"affine",u=u||"affine";let p,c,m,g,d,F,b,y;"G1"==e?("affine"==f?(p=2*i.F.n8,g="g1m_batchToJacobian"):p=3*i.F.n8,c=3*i.F.n8,o&&(y="g1m_fftFinal"),b="g1m_fftJoin",F="g1m_fftMix","affine"==u?(m=2*i.F.n8,d="g1m_batchToAffine"):m=3*i.F.n8):"G2"==e?("affine"==f?(p=2*i.F.n8,g="g2m_batchToJacobian"):p=3*i.F.n8,c=3*i.F.n8,o&&(y="g2m_fftFinal"),b="g2m_fftJoin",F="g2m_fftMix","affine"==u?(m=2*i.F.n8,d="g2m_batchToAffine"):m=3*i.F.n8):"Fr"==e&&(p=i.n8,c=i.n8,m=i.n8,o&&(y="frm_fftFinal"),F="frm_fftMix",b="frm_fftJoin");let w=!1;Array.isArray(t)?(t=he(t,p),w=!0):t=t.slice(0,t.byteLength);const L=t.byteLength/p,v=Ht(L);if(1<<v!=L)throw new Error("fft must be multiple of 2");if(v==s.s+1){let e;return e=o?await async function(t,e,i,n,o){let f,u;f=t.slice(0,t.byteLength/2),u=t.slice(t.byteLength/2,t.byteLength);const a=[];a.push(r(f,!0,e,"jacobian",n,o)),a.push(r(u,!0,e,"jacobian",n,o)),[f,u]=await Promise.all(a);const l=await h(f,u,"fftJoinExtInv",s.one,s.shiftInv,"jacobian",i,n,o);let p;p=l[0].byteLength>1<<28?new pe(2*l[0].byteLength):new Uint8Array(2*l[0].byteLength);return p.set(l[0]),p.set(l[1],l[0].byteLength),p}(t,f,u,a,l):await async function(t,e,i,n,o){let f,u;f=t.slice(0,t.byteLength/2),u=t.slice(t.byteLength/2,t.byteLength);const a=[];[f,u]=await h(f,u,"fftJoinExt",s.one,s.shift,e,"jacobian",n,o),a.push(r(f,!1,"jacobian",i,n,o)),a.push(r(u,!1,"jacobian",i,n,o));const l=await Promise.all(a);let p;p=l[0].byteLength>1<<28?new pe(2*l[0].byteLength):new Uint8Array(2*l[0].byteLength);return p.set(l[0]),p.set(l[1],l[0].byteLength),p}(t,f,u,a,l),w?oe(e,m):e}let B,q,E;o&&(B=s.inv(s.e(L))),Yt(t,p);let O=Math.min(16384,L),_=L/O;for(;_<n.concurrency&&O>=16;)_*=2,O/=2;const A=Ht(O),R=[];for(let e=0;e<_;e++){a&&a.debug(`${l}: fft ${v} mix start: ${e}/${_}`);const i=[];i.push({cmd:"ALLOC",var:0,len:c*O});const s=t.slice(O*e*p,O*(e+1)*p);i.push({cmd:"SET",var:0,buff:s}),g&&i.push({cmd:"CALL",fnName:g,params:[{var:0},{val:O},{var:0}]});for(let t=1;t<=A;t++)i.push({cmd:"CALL",fnName:F,params:[{var:0},{val:O},{val:t}]});A==v?(y&&(i.push({cmd:"ALLOCSET",var:1,buff:B}),i.push({cmd:"CALL",fnName:y,params:[{var:0},{val:O},{var:1}]})),d&&i.push({cmd:"CALL",fnName:d,params:[{var:0},{val:O},{var:0}]}),i.push({cmd:"GET",out:0,var:0,len:O*m})):i.push({cmd:"GET",out:0,var:0,len:c*O}),R.push(n.queueAction(i).then((t=>(a&&a.debug(`${l}: fft ${v} mix end: ${e}/${_}`),t))))}E=await Promise.all(R);for(let e=0;e<_;e++)E[e]=E[e][0];for(let e=A+1;e<=v;e++){a&&a.debug(`${l}: fft  ${v}  join: ${e}/${v}`);const t=1<<v-e,i=_/t,r=[];for(let o=0;o<t;o++)for(let h=0;h<i/2;h++){const f=s.exp(s.w[e],h*O),u=s.w[e],p=o*i+h,g=o*i+h+i/2,F=[];F.push({cmd:"ALLOCSET",var:0,buff:E[p]}),F.push({cmd:"ALLOCSET",var:1,buff:E[g]}),F.push({cmd:"ALLOCSET",var:2,buff:f}),F.push({cmd:"ALLOCSET",var:3,buff:u}),F.push({cmd:"CALL",fnName:b,params:[{var:0},{var:1},{val:O},{var:2},{var:3}]}),e==v?(y&&(F.push({cmd:"ALLOCSET",var:4,buff:B}),F.push({cmd:"CALL",fnName:y,params:[{var:0},{val:O},{var:4}]}),F.push({cmd:"CALL",fnName:y,params:[{var:1},{val:O},{var:4}]})),d&&(F.push({cmd:"CALL",fnName:d,params:[{var:0},{val:O},{var:0}]}),F.push({cmd:"CALL",fnName:d,params:[{var:1},{val:O},{var:1}]})),F.push({cmd:"GET",out:0,var:0,len:O*m}),F.push({cmd:"GET",out:1,var:1,len:O*m})):(F.push({cmd:"GET",out:0,var:0,len:O*c}),F.push({cmd:"GET",out:1,var:1,len:O*c})),r.push(n.queueAction(F).then((s=>(a&&a.debug(`${l}: fft ${v} join  ${e}/${v}  ${o+1}/${t} ${h}/${i/2}`),s))))}const h=await Promise.all(r);for(let e=0;e<t;e++)for(let t=0;t<i/2;t++){const s=e*i+t,n=e*i+t+i/2,r=h.shift();E[s]=r[0],E[n]=r[1]}}if(q=t instanceof pe?new pe(L*m):new Uint8Array(L*m),o){q.set(E[0].slice((O-1)*m));let t=m;for(let e=_-1;e>0;e--)q.set(E[e],t),t+=O*m,delete E[e];q.set(E[0].slice(0,(O-1)*m),t),delete E[0]}else for(let e=0;e<_;e++)q.set(E[e],O*m*e),delete E[e];return w?oe(q,m):q}async function h(t,r,h,o,f,u,a,l,p){let c,m,g,d,F,b;if("G1"==e)"affine"==u?(F=2*i.F.n8,m="g1m_batchToJacobian"):F=3*i.F.n8,b=3*i.F.n8,c="g1m_"+h,"affine"==a?(g="g1m_batchToAffine",d=2*i.F.n8):d=3*i.F.n8;else if("G2"==e)"affine"==u?(F=2*i.F.n8,m="g2m_batchToJacobian"):F=3*i.F.n8,c="g2m_"+h,b=3*i.F.n8,"affine"==a?(g="g2m_batchToAffine",d=2*i.F.n8):d=3*i.F.n8;else{if("Fr"!=e)throw new Error("Invalid group");F=s.n8,d=s.n8,b=s.n8,c="frm_"+h}if(t.byteLength!=r.byteLength)throw new Error("Invalid buffer size");const y=Math.floor(t.byteLength/F);if(y!=1<<Ht(y))throw new Error("Invalid number of points");let w=Math.floor(y/n.concurrency);w<16&&(w=16),w>65536&&(w=65536);const L=[];for(let e=0;e<y;e+=w){l&&l.debug(`${p}: fftJoinExt Start: ${e}/${y}`);const i=Math.min(y-e,w),h=s.mul(o,s.exp(f,e)),u=[],a=t.slice(e*F,(e+i)*F),v=r.slice(e*F,(e+i)*F);u.push({cmd:"ALLOC",var:0,len:b*i}),u.push({cmd:"SET",var:0,buff:a}),u.push({cmd:"ALLOC",var:1,len:b*i}),u.push({cmd:"SET",var:1,buff:v}),u.push({cmd:"ALLOCSET",var:2,buff:h}),u.push({cmd:"ALLOCSET",var:3,buff:f}),m&&(u.push({cmd:"CALL",fnName:m,params:[{var:0},{val:i},{var:0}]}),u.push({cmd:"CALL",fnName:m,params:[{var:1},{val:i},{var:1}]})),u.push({cmd:"CALL",fnName:c,params:[{var:0},{var:1},{val:i},{var:2},{var:3},{val:s.s}]}),g&&(u.push({cmd:"CALL",fnName:g,params:[{var:0},{val:i},{var:0}]}),u.push({cmd:"CALL",fnName:g,params:[{var:1},{val:i},{var:1}]})),u.push({cmd:"GET",out:0,var:0,len:i*d}),u.push({cmd:"GET",out:1,var:1,len:i*d}),L.push(n.queueAction(u).then((t=>(l&&l.debug(`${p}: fftJoinExt End: ${e}/${y}`),t))))}const v=await Promise.all(L);let B,q;y*d>1<<28?(B=new pe(y*d),q=new pe(y*d)):(B=new Uint8Array(y*d),q=new Uint8Array(y*d));let E=0;for(let e=0;e<v.length;e++)B.set(v[e][0],E),q.set(v[e][1],E),E+=v[e][0].byteLength;return[B,q]}i.fft=async function(t,e,i,s,n){return await r(t,!1,e,i,s,n)},i.ifft=async function(t,e,i,s,n){return await r(t,!0,e,i,s,n)},i.lagrangeEvaluations=async function(t,n,o,f,u){let a;if(n=n||"affine",o=o||"affine","G1"==e)a="affine"==n?2*i.F.n8:3*i.F.n8;else if("G2"==e)a="affine"==n?2*i.F.n8:3*i.F.n8;else{if("Fr"!=e)throw new Error("Invalid group");a=s.n8}const l=t.byteLength/a,p=Ht(l);if(2**p*a!=t.byteLength)throw f&&f.error("lagrangeEvaluations iinvalid input size"),new Error("lagrangeEvaluations invalid Input size");if(p<=s.s)return await i.ifft(t,n,o,f,u);if(p>s.s+1)throw f&&f.error("lagrangeEvaluations input too big"),new Error("lagrangeEvaluations input too big");let c=t.slice(0,t.byteLength/2),m=t.slice(t.byteLength/2,t.byteLength);const g=s.exp(s.shift,l/2),d=s.inv(s.sub(s.one,g));[c,m]=await h(c,m,"prepareLagrangeEvaluation",d,s.shiftInv,n,"jacobian",f,u+" prep");const F=[];let b;return F.push(r(c,!0,"jacobian",o,f,u+" t0")),F.push(r(m,!0,"jacobian",o,f,u+" t1")),[c,m]=await Promise.all(F),b=c.byteLength>1<<28?new pe(2*c.byteLength):new Uint8Array(2*c.byteLength),b.set(c),b.set(m,c.byteLength),b},i.fftMix=async function(t){const r=3*i.F.n8;let h,o;if("G1"==e)h="g1m_fftMix",o="g1m_fftJoin";else if("G2"==e)h="g2m_fftMix",o="g2m_fftJoin";else{if("Fr"!=e)throw new Error("Invalid group");h="frm_fftMix",o="frm_fftJoin"}const f=Math.floor(t.byteLength/r),u=Ht(f);let a=1<<Ht(n.concurrency);f<=2*a&&(a=1);const l=f/a,p=Ht(l),c=[];for(let e=0;e<a;e++){const i=[],s=t.slice(e*l*r,(e+1)*l*r);i.push({cmd:"ALLOCSET",var:0,buff:s});for(let t=1;t<=p;t++)i.push({cmd:"CALL",fnName:h,params:[{var:0},{val:l},{val:t}]});i.push({cmd:"GET",out:0,var:0,len:l*r}),c.push(n.queueAction(i))}const m=await Promise.all(c),g=[];for(let e=0;e<m.length;e++)g[e]=m[e][0];for(let e=p+1;e<=u;e++){const t=1<<u-e,i=a/t,h=[];for(let u=0;u<t;u++)for(let t=0;t<i/2;t++){const f=s.exp(s.w[e],t*l),a=s.w[e],p=u*i+t,c=u*i+t+i/2,m=[];m.push({cmd:"ALLOCSET",var:0,buff:g[p]}),m.push({cmd:"ALLOCSET",var:1,buff:g[c]}),m.push({cmd:"ALLOCSET",var:2,buff:f}),m.push({cmd:"ALLOCSET",var:3,buff:a}),m.push({cmd:"CALL",fnName:o,params:[{var:0},{var:1},{val:l},{var:2},{var:3}]}),m.push({cmd:"GET",out:0,var:0,len:l*r}),m.push({cmd:"GET",out:1,var:1,len:l*r}),h.push(n.queueAction(m))}const f=await Promise.all(h);for(let e=0;e<t;e++)for(let t=0;t<i/2;t++){const s=e*i+t,n=e*i+t+i/2,r=f.shift();g[s]=r[0],g[n]=r[1]}}let d;d=t instanceof pe?new pe(f*r):new Uint8Array(f*r);let F=0;for(let e=0;e<a;e++)d.set(g[e],F),F+=g[e].byteLength;return d},i.fftJoin=async function(t,r,h,o){const f=3*i.F.n8;let u;if("G1"==e)u="g1m_fftJoin";else if("G2"==e)u="g2m_fftJoin";else{if("Fr"!=e)throw new Error("Invalid group");u="frm_fftJoin"}if(t.byteLength!=r.byteLength)throw new Error("Invalid buffer size");const a=Math.floor(t.byteLength/f);if(a!=1<<Ht(a))throw new Error("Invalid number of points");let l=1<<Ht(n.concurrency);a<=2*l&&(l=1);const p=a/l,c=[];for(let e=0;e<l;e++){const i=[],a=s.mul(h,s.exp(o,e*p)),l=t.slice(e*p*f,(e+1)*p*f),m=r.slice(e*p*f,(e+1)*p*f);i.push({cmd:"ALLOCSET",var:0,buff:l}),i.push({cmd:"ALLOCSET",var:1,buff:m}),i.push({cmd:"ALLOCSET",var:2,buff:a}),i.push({cmd:"ALLOCSET",var:3,buff:o}),i.push({cmd:"CALL",fnName:u,params:[{var:0},{var:1},{val:p},{var:2},{var:3}]}),i.push({cmd:"GET",out:0,var:0,len:p*f}),i.push({cmd:"GET",out:1,var:1,len:p*f}),c.push(n.queueAction(i))}const m=await Promise.all(c);let g,d;t instanceof pe?(g=new pe(a*f),d=new pe(a*f)):(g=new Uint8Array(a*f),d=new Uint8Array(a*f));let F=0;for(let e=0;e<m.length;e++)g.set(m[e][0],F),d.set(m[e][1],F),F+=m[e][0].byteLength;return[g,d]},i.fftFinal=async function(t,s){const r=3*i.F.n8,h=2*i.F.n8;let o,f;if("G1"==e)o="g1m_fftFinal",f="g1m_batchToAffine";else{if("G2"!=e)throw new Error("Invalid group");o="g2m_fftFinal",f="g2m_batchToAffine"}const u=Math.floor(t.byteLength/r);if(u!=1<<Ht(u))throw new Error("Invalid number of points");const a=Math.floor(u/n.concurrency),l=[];for(let e=0;e<n.concurrency;e++){let i;if(i=e<n.concurrency-1?a:u-e*a,0==i)continue;const p=[],c=t.slice(e*a*r,(e*a+i)*r);p.push({cmd:"ALLOCSET",var:0,buff:c}),p.push({cmd:"ALLOCSET",var:1,buff:s}),p.push({cmd:"CALL",fnName:o,params:[{var:0},{val:i},{var:1}]}),p.push({cmd:"CALL",fnName:f,params:[{var:0},{val:i},{var:0}]}),p.push({cmd:"GET",out:0,var:0,len:i*h}),l.push(n.queueAction(p))}const p=await Promise.all(l);let c;c=t instanceof pe?new pe(u*h):new Uint8Array(u*h);let m=0;for(let e=p.length-1;e>=0;e--)c.set(p[e][0],m),m+=p[e][0].byteLength;return c}}async function _e(t){const e=await async function(t,e){const i=new ve;i.memory=new WebAssembly.Memory({initial:25}),i.u8=new Uint8Array(i.memory.buffer),i.u32=new Uint32Array(i.memory.buffer);const s=await WebAssembly.compile(t.code);if(i.instance=await WebAssembly.instantiate(s,{env:{memory:i.memory}}),i.singleThread=e,i.initalPFree=i.u32[0],i.pq=t.pq,i.pr=t.pr,i.pG1gen=t.pG1gen,i.pG1zero=t.pG1zero,i.pG2gen=t.pG2gen,i.pG2zero=t.pG2zero,i.pOneT=t.pOneT,e)i.code=t.code,i.taskManager=be(),await i.taskManager([{cmd:"INIT",init:25,code:i.code.slice()}]),i.concurrency=1;else{let e;i.workers=[],i.pendingDeferreds=[],i.working=[],e="object"===typeof navigator&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:a.default.cpus().length,0==e&&(e=2),e>64&&(e=64),i.concurrency=e;for(let t=0;t<e;t++)i.workers[t]=new l.default(Le),i.workers[t].addEventListener("message",n(t)),i.working[t]=!1;const s=[];for(let n=0;n<i.workers.length;n++){const e=t.code.slice();s.push(i.postAction(n,[{cmd:"INIT",init:25,code:e}],[e.buffer]))}await Promise.all(s)}return i;function n(t){return function(e){let s;s=e&&e.data?e.data:e,i.working[t]=!1,i.pendingDeferreds[t].resolve(s),i.processWorks()}}}(t.wasm,t.singleThread),i={};return i.q=N(t.wasm.q.toString()),i.r=N(t.wasm.r.toString()),i.name=t.name,i.tm=e,i.prePSize=t.wasm.prePSize,i.preQSize=t.wasm.preQSize,i.Fr=new me(e,"frm",t.n8r,t.r),i.F1=new me(e,"f1m",t.n8q,t.q),i.F2=new ge(e,"f2m",i.F1),i.G1=new Fe(e,"g1m",i.F1,t.wasm.pG1gen,t.wasm.pG1b,t.cofactorG1),i.G2=new Fe(e,"g2m",i.F2,t.wasm.pG2gen,t.wasm.pG2b,t.cofactorG2),i.F6=new de(e,"f6m",i.F2),i.F12=new ge(e,"ftm",i.F6),i.Gt=i.F12,Be(i,"G1"),Be(i,"G2"),Be(i,"Fr"),Ee(i,"G1"),Ee(i,"G2"),Oe(i,"G1"),Oe(i,"G2"),Oe(i,"Fr"),function(t){const e=t.tm;t.pairing=function(i,s){e.startSyncOp();const n=e.allocBuff(t.G1.toJacobian(i)),r=e.allocBuff(t.G2.toJacobian(s)),h=e.alloc(t.Gt.n8);e.instance.exports[t.name+"_pairing"](n,r,h);const o=e.getBuff(h,t.Gt.n8);return e.endSyncOp(),o},t.pairingEq=async function(){let i,s;arguments.length%2==1?(i=arguments[arguments.length-1],s=(arguments.length-1)/2):(i=t.Gt.one,s=arguments.length/2);const n=[];for(let u=0;u<s;u++){const i=[],s=t.G1.toJacobian(arguments[2*u]);i.push({cmd:"ALLOCSET",var:0,buff:s}),i.push({cmd:"ALLOC",var:1,len:t.prePSize});const r=t.G2.toJacobian(arguments[2*u+1]);i.push({cmd:"ALLOCSET",var:2,buff:r}),i.push({cmd:"ALLOC",var:3,len:t.preQSize}),i.push({cmd:"ALLOC",var:4,len:t.Gt.n8}),i.push({cmd:"CALL",fnName:t.name+"_prepareG1",params:[{var:0},{var:1}]}),i.push({cmd:"CALL",fnName:t.name+"_prepareG2",params:[{var:2},{var:3}]}),i.push({cmd:"CALL",fnName:t.name+"_millerLoop",params:[{var:1},{var:3},{var:4}]}),i.push({cmd:"GET",out:0,var:4,len:t.Gt.n8}),n.push(e.queueAction(i))}const r=await Promise.all(n);e.startSyncOp();const h=e.alloc(t.Gt.n8);e.instance.exports.ftm_one(h);for(let t=0;t<r.length;t++){const i=e.allocBuff(r[t][0]);e.instance.exports.ftm_mul(h,i,h)}e.instance.exports[t.name+"_finalExponentiation"](h,h);const o=e.allocBuff(i),f=!!e.instance.exports.ftm_eq(h,o);return e.endSyncOp(),f},t.prepareG1=function(t){this.tm.startSyncOp();const e=this.tm.allocBuff(t),i=this.tm.alloc(this.prePSize);this.tm.instance.exports[this.name+"_prepareG1"](e,i);const s=this.tm.getBuff(i,this.prePSize);return this.tm.endSyncOp(),s},t.prepareG2=function(t){this.tm.startSyncOp();const e=this.tm.allocBuff(t),i=this.tm.alloc(this.preQSize);this.tm.instance.exports[this.name+"_prepareG2"](e,i);const s=this.tm.getBuff(i,this.preQSize);return this.tm.endSyncOp(),s},t.millerLoop=function(t,e){this.tm.startSyncOp();const i=this.tm.allocBuff(t),s=this.tm.allocBuff(e),n=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_millerLoop"](i,s,n);const r=this.tm.getBuff(n,this.Gt.n8);return this.tm.endSyncOp(),r},t.finalExponentiation=function(t){this.tm.startSyncOp();const e=this.tm.allocBuff(t),i=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_finalExponentiation"](e,i);const s=this.tm.getBuff(i,this.Gt.n8);return this.tm.endSyncOp(),s}}(i),i.array2buffer=function(t,e){const i=new Uint8Array(e*t.length);for(let s=0;s<t.length;s++)i.set(t[s],s*e);return i},i.buffer2array=function(t,e){const i=t.byteLength/e,s=new Array(i);for(let n=0;n<i;n++)s[n]=t.slice(n*e,n*e+e);return s},i}async function Ae(t,e){const i=new o.ModuleBuilder;i.setMemory(25),n.buildBn128(i),e&&e(i);const s={};if(s.code=i.build(),s.pq=i.modules.f1m.pq,s.pr=i.modules.frm.pq,s.pG1gen=i.modules.bn128.pG1gen,s.pG1zero=i.modules.bn128.pG1zero,s.pG1b=i.modules.bn128.pG1b,s.pG2gen=i.modules.bn128.pG2gen,s.pG2zero=i.modules.bn128.pG2zero,s.pG2b=i.modules.bn128.pG2b,s.pOneT=i.modules.bn128.pOneT,s.prePSize=i.modules.bn128.prePSize,s.preQSize=i.modules.bn128.preQSize,s.n8q=32,s.n8r=32,s.q=i.modules.bn128.q,s.r=i.modules.bn128.r,!t&&globalThis.curve_bn128)return globalThis.curve_bn128;const r={name:"bn128",wasm:s,q:N("21888242871839275222246405745257275088696311157297823662689037894645226208583"),r:N("21888242871839275222246405745257275088548364400416034343698204186575808495617"),n8q:32,n8r:32,cofactorG2:N("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d",16),singleThread:!!t},h=await _e(r);return h.terminate=async function(){r.singleThread||(globalThis.curve_bn128=null,await this.tm.terminate())},t||(globalThis.curve_bn128=h),h}async function Re(t,e){const i=new o.ModuleBuilder;i.setMemory(25),n.buildBls12381(i),e&&e(i);const s={};if(s.code=i.build(),s.pq=i.modules.f1m.pq,s.pr=i.modules.frm.pq,s.pG1gen=i.modules.bls12381.pG1gen,s.pG1zero=i.modules.bls12381.pG1zero,s.pG1b=i.modules.bls12381.pG1b,s.pG2gen=i.modules.bls12381.pG2gen,s.pG2zero=i.modules.bls12381.pG2zero,s.pG2b=i.modules.bls12381.pG2b,s.pOneT=i.modules.bls12381.pOneT,s.prePSize=i.modules.bls12381.prePSize,s.preQSize=i.modules.bls12381.preQSize,s.n8q=48,s.n8r=32,s.q=i.modules.bls12381.q,s.r=i.modules.bls12381.r,!t&&globalThis.curve_bls12381)return globalThis.curve_bls12381;const r={name:"bls12381",wasm:s,q:N("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),r:N("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n8q:48,n8r:32,cofactorG1:N("0x396c8c005555e1568c00aaab0000aaab",16),cofactorG2:N("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5",16),singleThread:!!t},h=await _e(r);return h.terminate=async function(){r.singleThread||(globalThis.curve_bls12381=null,await this.tm.terminate())},t||(globalThis.curve_bls12381=h),h}globalThis.curve_bn128=null,globalThis.curve_bls12381=null;const xe=N("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),ze=N("21888242871839275222246405745257275088548364400416034343698204186575808495617"),Ie=N("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),Me=N("21888242871839275222246405745257275088696311157297823662689037894645226208583");const Se=wt,Te=ae;e.BigBuffer=pe,e.ChaCha=It,e.EC=class{constructor(t,e){this.F=t,this.g=e,2==this.g.length&&(this.g[2]=this.F.one),this.zero=[this.F.zero,this.F.one,this.F.zero]}add(t,e){const i=this.F;if(this.eq(t,this.zero))return e;if(this.eq(e,this.zero))return t;const s=new Array(3),n=i.square(t[2]),r=i.square(e[2]),h=i.mul(t[0],r),o=i.mul(e[0],n),f=i.mul(t[2],n),u=i.mul(e[2],r),a=i.mul(t[1],u),l=i.mul(e[1],f);if(i.eq(h,o)&&i.eq(a,l))return this.double(t);const p=i.sub(o,h),c=i.sub(l,a),m=i.square(i.add(p,p)),g=i.mul(p,m),d=i.add(c,c),F=i.mul(h,m);s[0]=i.sub(i.sub(i.square(d),g),i.add(F,F));const b=i.mul(a,g);return s[1]=i.sub(i.mul(d,i.sub(F,s[0])),i.add(b,b)),s[2]=i.mul(p,i.sub(i.square(i.add(t[2],e[2])),i.add(n,r))),s}neg(t){return[t[0],this.F.neg(t[1]),t[2]]}sub(t,e){return this.add(t,this.neg(e))}double(t){const e=this.F,i=new Array(3);if(this.eq(t,this.zero))return t;const s=e.square(t[0]),n=e.square(t[1]),r=e.square(n);let h=e.sub(e.square(e.add(t[0],n)),e.add(s,r));h=e.add(h,h);const o=e.add(e.add(s,s),s),f=e.square(o);i[0]=e.sub(f,e.add(h,h));let u=e.add(r,r);u=e.add(u,u),u=e.add(u,u),i[1]=e.sub(e.mul(o,e.sub(h,i[0])),u);const a=e.mul(t[1],t[2]);return i[2]=e.add(a,a),i}timesScalar(t,e){return At(this,t,e)}mulScalar(t,e){return At(this,t,e)}affine(t){const e=this.F;if(this.isZero(t))return this.zero;if(e.eq(t[2],e.one))return t;{const i=e.inv(t[2]),s=e.square(i),n=e.mul(s,i),r=new Array(3);return r[0]=e.mul(t[0],s),r[1]=e.mul(t[1],n),r[2]=e.one,r}}multiAffine(t){const e=Object.keys(t),i=this.F,s=new Array(e.length+1);s[0]=i.one;for(let n=0;n<e.length;n++)i.eq(t[e[n]][2],i.zero)?s[n+1]=s[n]:s[n+1]=i.mul(s[n],t[e[n]][2]);s[e.length]=i.inv(s[e.length]);for(let n=e.length-1;n>=0;n--)if(i.eq(t[e[n]][2],i.zero))s[n]=s[n+1],t[e[n]]=this.zero;else{const r=i.mul(s[n],s[n+1]);s[n]=i.mul(t[e[n]][2],s[n+1]);const h=i.square(r),o=i.mul(h,r);t[e[n]][0]=i.mul(t[e[n]][0],h),t[e[n]][1]=i.mul(t[e[n]][1],o),t[e[n]][2]=i.one}}eq(t,e){const i=this.F;if(this.F.eq(t[2],this.F.zero))return this.F.eq(e[2],this.F.zero);if(this.F.eq(e[2],this.F.zero))return!1;const s=i.square(t[2]),n=i.square(e[2]),r=i.mul(t[0],n),h=i.mul(e[0],s),o=i.mul(t[2],s),f=i.mul(e[2],n),u=i.mul(t[1],f),a=i.mul(e[1],o);return i.eq(r,h)&&i.eq(u,a)}isZero(t){return this.F.isZero(t[2])}toString(t){const e=this.affine(t);return`[ ${this.F.toString(e[0])} , ${this.F.toString(e[1])} ]`}fromRng(t){const e=this.F;let i,s=[];do{s[0]=e.fromRng(t),i=t.nextBool();const n=e.add(e.mul(e.square(s[0]),s[0]),this.b);s[1]=e.sqrt(n)}while(null==s[1]||e.isZero[s]);return i^Jt(e,s[1])&&(s[1]=e.neg(s[1])),s[2]=e.one,this.cofactor&&(s=this.mulScalar(s,this.cofactor)),s=this.affine(s),s}toRprLE(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprLE(t,e,i[0]),this.F.toRprLE(t,e+this.F.n8,i[1])}toRprBE(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprBE(t,e,i[0]),this.F.toRprBE(t,e+this.F.n8,i[1])}toRprLEM(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1])}toRprLEJM(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1]),this.F.toRprLEM(t,e+2*this.F.n8,i[2])}toRprBEM(t,e,i){if(i=this.affine(i),this.isZero(i)){new Uint8Array(t,e,2*this.F.n8).fill(0)}else this.F.toRprBEM(t,e,i[0]),this.F.toRprBEM(t,e+this.F.n8,i[1])}fromRprLE(t,e){e=e||0;const i=this.F.fromRprLE(t,e),s=this.F.fromRprLE(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(s)?this.zero:[i,s,this.F.one]}fromRprBE(t,e){e=e||0;const i=this.F.fromRprBE(t,e),s=this.F.fromRprBE(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(s)?this.zero:[i,s,this.F.one]}fromRprLEM(t,e){e=e||0;const i=this.F.fromRprLEM(t,e),s=this.F.fromRprLEM(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(s)?this.zero:[i,s,this.F.one]}fromRprLEJM(t,e){e=e||0;const i=this.F.fromRprLEM(t,e),s=this.F.fromRprLEM(t,e+this.F.n8),n=this.F.fromRprLEM(t,e+2*this.F.n8);return this.F.isZero(i)&&this.F.isZero(s)?this.zero:[i,s,n]}fromRprBEM(t,e){e=e||0;const i=this.F.fromRprBEM(t,e),s=this.F.fromRprBEM(t,e+this.F.n8);return this.F.isZero(i)&&this.F.isZero(s)?this.zero:[i,s,this.F.one]}fromRprCompressed(t,e){const i=this.F,s=new Uint8Array(t.buffer,e,i.n8);if(64&s[0])return this.zero;const n=new Array(3),r=0!=(128&s[0]);s[0]=127&s[0],n[0]=i.fromRprBE(t,e),r&&(s[0]=128|s[0]);const h=i.add(i.mul(i.square(n[0]),n[0]),this.b);if(n[1]=i.sqrt(h),null===n[1])throw new Error("Invalid Point!");return r^Jt(i,n[1])&&(n[1]=i.neg(n[1])),n[2]=i.one,n}toRprCompressed(t,e,i){i=this.affine(i);const s=new Uint8Array(t.buffer,e,this.F.n8);if(this.isZero(i))return s.fill(0),void(s[0]=64);this.F.toRprBE(t,e,i[0]),Jt(this.F,i[1])&&(s[0]=128|s[0])}fromRprUncompressed(t,e){return 64&t[0]?this.zero:this.fromRprBE(t,e)}toRprUncompressed(t,e,i){this.toRprBE(t,e,i),this.isZero(i)&&(t[e]=64|t[e])}},e.F1Field=Pt,e.F2Field=class{constructor(t,e){this.type="F2",this.F=t,this.zero=[this.F.zero,this.F.zero],this.one=[this.F.one,this.F.zero],this.negone=this.neg(this.one),this.nonResidue=e,this.m=2*t.m,this.p=t.p,this.n64=2*t.n64,this.n32=2*this.n64,this.n8=8*this.n64,xt(this)}_mulByNonResidue(t){return this.F.mul(this.nonResidue,t)}copy(t){return[this.F.copy(t[0]),this.F.copy(t[1])]}add(t,e){return[this.F.add(t[0],e[0]),this.F.add(t[1],e[1])]}double(t){return this.add(t,t)}sub(t,e){return[this.F.sub(t[0],e[0]),this.F.sub(t[1],e[1])]}neg(t){return this.sub(this.zero,t)}conjugate(t){return[t[0],this.F.neg(t[1])]}mul(t,e){const i=this.F.mul(t[0],e[0]),s=this.F.mul(t[1],e[1]);return[this.F.add(i,this._mulByNonResidue(s)),this.F.sub(this.F.mul(this.F.add(t[0],t[1]),this.F.add(e[0],e[1])),this.F.add(i,s))]}inv(t){const e=this.F.square(t[0]),i=this.F.square(t[1]),s=this.F.sub(e,this._mulByNonResidue(i)),n=this.F.inv(s);return[this.F.mul(t[0],n),this.F.neg(this.F.mul(t[1],n))]}div(t,e){return this.mul(t,this.inv(e))}square(t){const e=this.F.mul(t[0],t[1]);return[this.F.sub(this.F.mul(this.F.add(t[0],t[1]),this.F.add(t[0],this._mulByNonResidue(t[1]))),this.F.add(e,this._mulByNonResidue(e))),this.F.add(e,e)]}isZero(t){return this.F.isZero(t[0])&&this.F.isZero(t[1])}eq(t,e){return this.F.eq(t[0],e[0])&&this.F.eq(t[1],e[1])}mulScalar(t,e){return At(this,t,e)}pow(t,e){return Rt(this,t,e)}exp(t,e){return Rt(this,t,e)}toString(t){return`[ ${this.F.toString(t[0])} , ${this.F.toString(t[1])} ]`}fromRng(t){return[this.F.fromRng(t),this.F.fromRng(t)]}gt(t,e){return!!this.F.gt(t[0],e[0])||!this.F.gt(e[0],t[0])&&!!this.F.gt(t[1],e[1])}geq(t,e){return this.gt(t,e)||this.eq(t,e)}lt(t,e){return!this.geq(t,e)}leq(t,e){return!this.gt(t,e)}neq(t,e){return!this.eq(t,e)}random(){return[this.F.random(),this.F.random()]}toRprLE(t,e,i){this.F.toRprLE(t,e,i[0]),this.F.toRprLE(t,e+this.F.n8,i[1])}toRprBE(t,e,i){this.F.toRprBE(t,e,i[1]),this.F.toRprBE(t,e+this.F.n8,i[0])}toRprLEM(t,e,i){this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1])}toRprBEM(t,e,i){this.F.toRprBEM(t,e,i[1]),this.F.toRprBEM(t,e+this.F.n8,i[0])}fromRprLE(t,e){e=e||0;return[this.F.fromRprLE(t,e),this.F.fromRprLE(t,e+this.F.n8)]}fromRprBE(t,e){e=e||0;const i=this.F.fromRprBE(t,e);return[this.F.fromRprBE(t,e+this.F.n8),i]}fromRprLEM(t,e){e=e||0;return[this.F.fromRprLEM(t,e),this.F.fromRprLEM(t,e+this.F.n8)]}fromRprBEM(t,e){e=e||0;const i=this.F.fromRprBEM(t,e);return[this.F.fromRprBEM(t,e+this.F.n8),i]}toObject(t){return t}},e.F3Field=class{constructor(t,e){this.type="F3",this.F=t,this.zero=[this.F.zero,this.F.zero,this.F.zero],this.one=[this.F.one,this.F.zero,this.F.zero],this.negone=this.neg(this.one),this.nonResidue=e,this.m=3*t.m,this.p=t.p,this.n64=3*t.n64,this.n32=2*this.n64,this.n8=8*this.n64}_mulByNonResidue(t){return this.F.mul(this.nonResidue,t)}copy(t){return[this.F.copy(t[0]),this.F.copy(t[1]),this.F.copy(t[2])]}add(t,e){return[this.F.add(t[0],e[0]),this.F.add(t[1],e[1]),this.F.add(t[2],e[2])]}double(t){return this.add(t,t)}sub(t,e){return[this.F.sub(t[0],e[0]),this.F.sub(t[1],e[1]),this.F.sub(t[2],e[2])]}neg(t){return this.sub(this.zero,t)}mul(t,e){const i=this.F.mul(t[0],e[0]),s=this.F.mul(t[1],e[1]),n=this.F.mul(t[2],e[2]);return[this.F.add(i,this._mulByNonResidue(this.F.sub(this.F.mul(this.F.add(t[1],t[2]),this.F.add(e[1],e[2])),this.F.add(s,n)))),this.F.add(this.F.sub(this.F.mul(this.F.add(t[0],t[1]),this.F.add(e[0],e[1])),this.F.add(i,s)),this._mulByNonResidue(n)),this.F.add(this.F.sub(this.F.mul(this.F.add(t[0],t[2]),this.F.add(e[0],e[2])),this.F.add(i,n)),s)]}inv(t){const e=this.F.square(t[0]),i=this.F.square(t[1]),s=this.F.square(t[2]),n=this.F.mul(t[0],t[1]),r=this.F.mul(t[0],t[2]),h=this.F.mul(t[1],t[2]),o=this.F.sub(e,this._mulByNonResidue(h)),f=this.F.sub(this._mulByNonResidue(s),n),u=this.F.sub(i,r),a=this.F.inv(this.F.add(this.F.mul(t[0],o),this._mulByNonResidue(this.F.add(this.F.mul(t[2],f),this.F.mul(t[1],u)))));return[this.F.mul(a,o),this.F.mul(a,f),this.F.mul(a,u)]}div(t,e){return this.mul(t,this.inv(e))}square(t){const e=this.F.square(t[0]),i=this.F.mul(t[0],t[1]),s=this.F.add(i,i),n=this.F.square(this.F.add(this.F.sub(t[0],t[1]),t[2])),r=this.F.mul(t[1],t[2]),h=this.F.add(r,r),o=this.F.square(t[2]);return[this.F.add(e,this._mulByNonResidue(h)),this.F.add(s,this._mulByNonResidue(o)),this.F.sub(this.F.add(this.F.add(s,n),h),this.F.add(e,o))]}isZero(t){return this.F.isZero(t[0])&&this.F.isZero(t[1])&&this.F.isZero(t[2])}eq(t,e){return this.F.eq(t[0],e[0])&&this.F.eq(t[1],e[1])&&this.F.eq(t[2],e[2])}affine(t){return[this.F.affine(t[0]),this.F.affine(t[1]),this.F.affine(t[2])]}mulScalar(t,e){return At(this,t,e)}pow(t,e){return Rt(this,t,e)}exp(t,e){return Rt(this,t,e)}toString(t){return`[ ${this.F.toString(t[0])} , ${this.F.toString(t[1])}, ${this.F.toString(t[2])} ]`}fromRng(t){return[this.F.fromRng(t),this.F.fromRng(t),this.F.fromRng(t)]}gt(t,e){return!!this.F.gt(t[0],e[0])||!this.F.gt(e[0],t[0])&&(!!this.F.gt(t[1],e[1])||!this.F.gt(e[1],t[1])&&!!this.F.gt(t[2],e[2]))}geq(t,e){return this.gt(t,e)||this.eq(t,e)}lt(t,e){return!this.geq(t,e)}leq(t,e){return!this.gt(t,e)}neq(t,e){return!this.eq(t,e)}random(){return[this.F.random(),this.F.random(),this.F.random()]}toRprLE(t,e,i){this.F.toRprLE(t,e,i[0]),this.F.toRprLE(t,e+this.F.n8,i[1]),this.F.toRprLE(t,e+2*this.F.n8,i[2])}toRprBE(t,e,i){this.F.toRprBE(t,e,i[2]),this.F.toRprBE(t,e+this.F.n8,i[1]),this.F.toRprBE(t,e+2*this.F.n8,i[0])}toRprLEM(t,e,i){this.F.toRprLEM(t,e,i[0]),this.F.toRprLEM(t,e+this.F.n8,i[1]),this.F.toRprLEM(t,e+2*this.F.n8,i[2])}toRprBEM(t,e,i){this.F.toRprBEM(t,e,i[2]),this.F.toRprBEM(t,e+this.F.n8,i[1]),this.F.toRprBEM(t,e+2*this.F.n8,i[0])}fromRprLE(t,e){e=e||0;return[this.F.fromRprLE(t,e),this.F.fromRprLE(t,e+this.n8),this.F.fromRprLE(t,e+2*this.n8)]}fromRprBE(t,e){e=e||0;const i=this.F.fromRprBE(t,e),s=this.F.fromRprBE(t,e+this.n8);return[this.F.fromRprBE(t,e+2*this.n8),s,i]}fromRprLEM(t,e){e=e||0;return[this.F.fromRprLEM(t,e),this.F.fromRprLEM(t,e+this.n8),this.F.fromRprLEM(t,e+2*this.n8)]}fromRprBEM(t,e){e=e||0;const i=this.F.fromRprBEM(t,e),s=this.F.fromRprBEM(t,e+this.n8);return[this.F.fromRprBEM(t,e+2*this.n8),s,i]}toObject(t){return t}},e.PolField=class{constructor(t){this.F=t;let e=t.sqrt_t,i=t.sqrt_s;const s=this.F.add(this.F.add(this.F.two,this.F.two),this.F.one);this.w=new Array(i+1),this.wi=new Array(i+1),this.w[i]=this.F.pow(s,e),this.wi[i]=this.F.inv(this.w[i]);let n=i-1;for(;n>=0;)this.w[n]=this.F.square(this.w[n+1]),this.wi[n]=this.F.square(this.wi[n+1]),n--;this.roots=[],this._setRoots(15)}_setRoots(t){t>this.F.sqrt_s&&(t=this.s);for(let e=t;e>=0&&!this.roots[e];e--){let t=this.F.one;const i=1<<e,s=new Array(i);for(let n=0;n<i;n++)s[n]=t,t=this.F.mul(t,this.w[e]);this.roots[e]=s}}add(t,e){const i=Math.max(t.length,e.length),s=new Array(i);for(let n=0;n<i;n++)s[n]=this.F.add(t[n]||this.F.zero,e[n]||this.F.zero);return this.reduce(s)}double(t){return this.add(t,t)}sub(t,e){const i=Math.max(t.length,e.length),s=new Array(i);for(let n=0;n<i;n++)s[n]=this.F.sub(t[n]||this.F.zero,e[n]||this.F.zero);return this.reduce(s)}mulScalar(t,e){if(this.F.eq(e,this.F.zero))return[];if(this.F.eq(e,this.F.one))return t;const i=new Array(t.length);for(let s=0;s<t.length;s++)i[s]=this.F.mul(t[s],e);return i}mul(t,e){return 0==t.length||0==e.length?[]:1==t.length?this.mulScalar(e,t[0]):1==e.length?this.mulScalar(t,e[0]):(e.length>t.length&&([e,t]=[t,e]),e.length<=2||e.length<Lt(t.length)?this.mulNormal(t,e):this.mulFFT(t,e))}mulNormal(t,e){let i=[];for(let s=0;s<e.length;s++)i=this.add(i,this.scaleX(this.mulScalar(t,e[s]),s));return i}mulFFT(t,e){const i=Lt(Math.max(t.length,e.length)-1)+2;this._setRoots(i);const s=1<<i,n=this.extend(t,s),r=this.extend(e,s),h=vt(this,n,i,0,1),o=vt(this,r,i,0,1),f=new Array(s);for(let p=0;p<s;p++)f[p]=this.F.mul(h[p],o[p]);const u=vt(this,f,i,0,1),a=this.F.inv(this.F.mulScalar(this.F.one,s)),l=new Array(s);for(let p=0;p<s;p++)l[p]=this.F.mul(u[(s-p)%s],a);return this.reduce(l)}square(t){return this.mul(t,t)}scaleX(t,e){if(0==e)return t;if(e>0){return new Array(e).fill(this.F.zero).concat(t)}return-e>=t.length?[]:t.slice(-e)}eval2(t,e){let i=this.F.zero,s=this.F.one;for(let n=0;n<t.length;n++)i=this.F.add(i,this.F.mul(t[n],s)),s=this.F.mul(s,e);return i}eval(t,e){const i=this.F;if(0==t.length)return i.zero;const s=this._next2Power(t.length);return function t(e,s,n,r,h){if(1==h)return e[n];const o=i.square(s),f=i.add(t(e,o,n,r<<1,h>>1),i.mul(s,t(e,o,n+r,r<<1,h>>1)));return f}(this.extend(t,s),e,0,1,s)}lagrange(t){let e=[this.F.one];for(let s=0;s<t.length;s++)e=this.mul(e,[this.F.neg(t[s][0]),this.F.one]);let i=[];for(let s=0;s<t.length;s++){let n=this.ruffini(e,t[s][0]);const r=this.F.mul(this.F.inv(this.eval(n,t[s][0])),t[s][1]);n=this.mulScalar(n,r),i=this.add(i,n)}return i}fft(t){if(t.length<=1)return t;const e=Lt(t.length-1)+1;this._setRoots(e);const i=1<<e;return vt(this,this.extend(t,i),e,0,1)}fft2(t){if(t.length<=1)return t;const e=Lt(t.length-1)+1;this._setRoots(e);const i=1<<e,s=this.extend(t,i);_t(s,e);return Bt(this,s,e)}ifft(t){if(t.length<=1)return t;const e=Lt(t.length-1)+1;this._setRoots(e);const i=1<<e,s=vt(this,this.extend(t,i),e,0,1),n=this.F.inv(this.F.mulScalar(this.F.one,i)),r=new Array(i);for(let h=0;h<i;h++)r[h]=this.F.mul(s[(i-h)%i],n);return r}ifft2(t){if(t.length<=1)return t;const e=Lt(t.length-1)+1;this._setRoots(e);const i=1<<e,s=this.extend(t,i);_t(s,e);const n=Bt(this,s,e),r=this.F.inv(this.F.mulScalar(this.F.one,i)),h=new Array(i);for(let o=0;o<i;o++)h[o]=this.F.mul(n[(i-o)%i],r);return h}_fft(t,e,i,s){const n=1<<e;if(1==n)return[t[i]];const r=n>>1,h=this._fft(t,e-1,i,2*s),o=this._fft(t,e-1,i+s,2*s),f=new Array(n);let u=this.F.one;for(let a=0;a<r;a++)f[a]=this.F.add(h[a],this.F.mul(u,o[a])),f[a+r]=this.F.sub(h[a],this.F.mul(u,o[a])),u=this.F.mul(u,this.w[e]);return f}extend(t,e){if(e==t.length)return t;const i=new Array(e-t.length).fill(this.F.zero);return t.concat(i)}reduce(t){if(0==t.length)return t;if(!this.F.eq(t[t.length-1],this.F.zero))return t;let e=t.length-1;for(;e>0&&this.F.eq(t[e],this.F.zero);)e--;return t.slice(0,e+1)}eq(t,e){const i=this.reduce(t),s=this.reduce(e);if(i.length!=s.length)return!1;for(let n=0;n<s.length;n++)if(!this.F.eq(i[n],s[n]))return!1;return!0}ruffini(t,e){const i=new Array(t.length-1);i[i.length-1]=t[t.length-1];for(let s=i.length-2;s>=0;s--)i[s]=this.F.add(this.F.mul(i[s+1],e),t[s+1]);return i}_next2Power(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t}toString(t){let e="";for(let i=this.normalize(t).length-1;i>=0;i--)this.F.eq(t[i],this.F.zero)||(""!=e&&(e+=" + "),e+=t[i].toString(10),i>0&&(e+="x",i>1&&(e=e+"^"+i)));return e}normalize(t){const e=new Array(t.length);for(let i=0;i<t.length;i++)e[i]=this.F.normalize(t[i]);return e}_reciprocal(t,e){const i=1<<e;if(1==i)return[this.F.inv(t[0])];const s=this.scaleX(t,-i/2),n=this._reciprocal(s,e-1),r=this.scaleX(this.double(n),3*i/2-2),h=this.mul(this.square(n),t);return this.scaleX(this.sub(r,h),-(i-2))}_div2(t,e){const i=Lt(e.length-1)+1,s=1<<i,n=s-e.length,r=this._reciprocal(this.scaleX(e,n),i);return this.scaleX(r,t-2*s+2+n)}div(t,e){if(t.length<e.length)return[];const i=Lt(e.length-1)+1,s=1<<i,n=this.scaleX(t,s-e.length),r=this.scaleX(e,s-e.length),h=r.length-1;let o=n.length-1;const f=this._reciprocal(r,i);let u;o>2*h&&(u=this.sub(this.scaleX([this.F.one],2*h),this.mul(f,r)));let a,l,p=[],c=n,m=!1;for(;!m;)a=this.mul(c,f),p=this.add(p,this.scaleX(a,-2*h)),o>2*h?(l=this.mul(c,u),c=this.scaleX(l,-2*h),o=c.length-1):m=!0;return p}oneRoot(t,e){let i=Lt(t-1)+1,s=this.F.one,n=e;if(e>=t)throw new Error("Given 'i' should be lower than 'n'");if(1<<i!==t)throw new Error(`Internal errlr: ${t} should equal ${1<<i}`);for(;n>0;)!0&n&&(s=this.F.mul(s,this.w[i])),n>>=1,i--;return s}computeVanishingPolinomial(t,e){const i=1<<t;return this.F.sub(this.F.pow(e,i),this.F.one)}evaluateLagrangePolynomials(t,e){const i=1<<t,s=this.F.pow(e,i),n=new Array(i).fill(this.F.zero);this._setRoots(t);const r=this.w[t];if(this.F.eq(s,this.F.one))for(let f=0;f<i;f++)if(this.F.eq(this.roots[t][0],e))return n[f]=this.F.one,n;const h=this.F.sub(s,this.F.one);let o=this.F.mul(h,this.F.inv(this.F.e(i)));for(let f=0;f<i;f++)n[f]=this.F.mul(o,this.F.inv(this.F.sub(e,this.roots[t][f]))),o=this.F.mul(o,r);return n}log2(t){return Lt(t)}},e.Scalar=Se,e.ZqField=Pt,e.buildBls12381=Re,e.buildBn128=Ae,e.getCurveFromName=async function(t,e,i){let s;const n=t.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(n)>=0)s=await Ae(e,i);else{if(!(["BLS12381"].indexOf(n)>=0))throw new Error(`Curve not supported: ${t}`);s=await Re(e,i)}return s},e.getCurveFromQ=async function(t,e,i){let s;if(ft(t,Me))s=await Ae(e,i);else{if(!ft(t,Ie))throw new Error(`Curve not supported: ${M(t,16)}`);s=await Re(e,i)}return s},e.getCurveFromR=async function(t,e,i){let s;if(ft(t,ze))s=await Ae(e,i);else{if(!ft(t,xe))throw new Error(`Curve not supported: ${M(t)}`);s=await Re(e,i)}return s},e.utils=Te}}]);